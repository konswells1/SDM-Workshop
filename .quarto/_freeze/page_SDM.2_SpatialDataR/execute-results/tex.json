{
  "hash": "e5f13804c1bc745e939066e40765db96",
  "result": {
    "engine": "knitr",
    "markdown": "title: \"Spatial Data in R\"\nformat: html\neditor: visual\n---\n\n\n::: {.cell}\n\n:::\n\n\n<br>\n\nThe **natural world is fundamentally spatial**. No organism exists in isolation; every ecological interaction occurs within a specific environmental context. Scientific observations gain meaning only when viewed within their spatial and temporal frame. Organisms are subject to the environmental conditions of their specific place and time. Whether prey is consumed and transformed through digestion or a leaf decomposes and returns to the soil, both processes follow fundamental pathways of pools and fluxes within the spatial and temporal fabric of life.\n\n<br>\n\n![Animated illustration of predator–prey movements across an environmental gradient, showing how ecological interactions unfold in space and time.](images/predator_prey_spatial.gif){width=\"500px\"}\n\n**Spatial data** form the foundation of **geographical analysis** and **ecological modeling**. In **R**, spatial data are typically managed in two primary formats: **vector** and **raster**.\n\n<br>\n\nRecognizing this perspective is essential in environmental science. Understanding nature’s patterns requires data that are organized with space and time in mind. Fortunately, modern data science in R offers an excellent toolkit for mapping these relationships and reminding us that even data, like organisms, thrive best in the right environment.\n\nBeyond data structure, it is increasingly recognized that ecological observations must be interpreted within an appropriate **spatiotemporal context**. Species responses depend not only on local environmental conditions, but also on **spatial patterns**, temporal dynamics, and **scale-dependent processes**. Ignoring these dimensions can obscure ecological signals or lead to misleading inferences about species–environment relationships.\n\nAdopting **tidy data principles** helps structure ecological data in ways that make relationships between observations, space, and time explicit. This not only supports more efficient and reproducible analysis, but also encourages **conceptual clarity**, enabling environmental scientists and practitioners to think carefully about what constitutes an observation, what variables describe it, and how they are interrelated. Such practices bridge ecological theory with modern data science workflows, enabling transparent model building, integration across datasets, and robust generalization of ecological insights. Ultimately, developing a general understanding of spatial data—and how it fits within broader data science concepts—is not a technical luxury, but a conceptual necessity. It strengthens one’s ability to formulate better ecological questions, design meaningful analyses, and translate data into insight about environmental change, biodiversity patterns, and ecosystem processes.\n\n<br>\n\n#### Vector data: Representing discrete features\n\n**Vector data** are used to represent **discrete spatial features** — objects with clear boundaries — such as:\n\n-   Tree or animal locations\\\n-   Roads or rivers\\\n-   Country or habitat boundaries\n\nVector features are commonly represented in three geometries:\n\n-   **Points**: Individual locations defined by coordinate pairs (e.g., species occurrences, weather stations).\n\n-   **Lines**: Linear features such as roads, rivers, or migration paths, represented by sequences of connected points.\n\n-   **Polygons**: Closed shapes that define areas like lakes, forest patches, or administrative zones.\n\nEach vector feature can also include **associated attributes**, stored in a data table linked to the geometry.\\\nThese might include:\n\n-   species_name\n-   survey_date\n-   population_count\n\n#### Raster Data: Representing Continuous Spatial Variables\n\n**Raster data** represent **continuous spatial phenomena** — variables that vary smoothly across space — such as:\n\n-   Elevation\n-   Temperature\n-   Vegetation indices (e.g., NDVI)\n\nA raster is composed of a **grid of cells** (also called *pixels*), where **each cell holds a single value** — either **numeric** (e.g., temperature) or **categorical** (e.g., land cover class).\n\n------------------------------------------------------------------------\n\n#### Structure of raster data\n\nUnlike vector data, **raster datasets do not store coordinates for each cell**. Instead, they rely on:\n\n-   **Spatial extent** – the geographic boundaries covered by the raster\\\n-   **Resolution** – the size of each cell (e.g., 25m x 25m)\\\n-   **Origin** – typically the top-left corner, which anchors the raster in space\n\nThese three components allow computational software like `R` to calculate the position of every cell efficiently.\n\n::: {.callout-tip collapse=\"true\" icon=\"compass\"}\n### Raster and pixels\n\nJust like digital images, **raster datasets** can vary in **resolution**, which directly affects both **spatial detail** and **file size**.\n\nHigher resolution means finer detail but larger file size, while lower resolution may be faster to process but less precise.\n:::\n\n------------------------------------------------------------------------\n\n##### Why it matters\n\nUnderstanding the differences, structures, and strengths of both vector and raster data is essential for:\n\n-   Spatial analysis\n-   Species distribution modeling\n-   Working with geographic information systems (GIS) in `R`\n\nThroughout this workshop, we’ll be using a number of GIS-focused packages in R. If any of these are not already installed on your system, you can install them using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"package_name\", dependencies = TRUE)\n```\n:::\n\n\nTo work with spatial vector and raster data, we’ll use the `terra` package (for more information, see <https://rspatial.org/index.html>).\n\nIf you haven’t installed it yet, you can run the following command in your R console (skip this step if it’s already installed):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"terra\", dependencies = TRUE)\n```\n:::\n\n\nOnce installed, load the package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n library(terra)\n```\n:::\n\n\n<br>\n\n## 1. Vector data in R - getting started\n\nVector data are at the core of spatial data analysis in ecology and environmental science. In `R`, vector data are typically managed using the **`terra`** or **`sf`** packages, both of which support reading, manipulating, and visualizing point, line, and polygon data.\n\nThe `terra` package (which we use in this workshop) handles spatial vector and raster data in an efficient, modern, and consistent way.\n\n------------------------------------------------------------------------\n\n## 1.1 Points in space\n\n### What are spatial points?\n\nPoints are the simplest vector data geometry and are used to represent **individual locations** in space, such as:\n\n-   Species occurrence records\\\n-   Weather stations\\\n-   Field survey sites\\\n-   GPS locations\n\nEach point is defined by a **coordinate pair**, typically in latitude/longitude (geographic) or projected coordinates (e.g., UTM).\n\n------------------------------------------------------------------------\n\n<br>\n\n### Creating points in `R` with `terra`\n\nYou can create spatial points manually using `vect()` from the `terra` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n\n# Define coordinates as a matrix for multiple cities (longitude, latitude)\ncoords <- matrix(c(\n  -1.2577, 51.7520,   # Oxford\n  12.4964, 41.9028,   # Rome\n  -3.9440, 51.6214,   # Swansea\n   8.6821, 50.1109,   # Frankfurt\n   8.5417, 47.3769,   # Zurich\n   2.3522, 48.8566    # Paris\n), ncol = 2, byrow = TRUE)\n\ncity_name <- c(\"Oxford\", \"Rome\", \"Swansea\", \"Frankfurt\", \"Zurich\", \"Paris\")\n\n# Create spatial vector of points (longitude, latitude)\npoints <- terra::vect(coords, type = \"points\", crs = \"EPSG:4326\")\npoints$city <- city_name\n\n# Get the extent of the points and expand it by 10% (for plotting)\next <- ext(points)\nx_range <- ext[1:2]\ny_range <- ext[3:4]\n\nx_margin <- diff(x_range) * 0.1\ny_margin <- diff(y_range) * 0.1\n\nx_ext <- c(x_range[1] - x_margin, x_range[2] + x_margin)\ny_ext <- c(y_range[1] - y_margin, y_range[2] + y_margin)\n\n# Plot the points with expanded plot extent\nplot(points, col = \"blue\", pch = 16, xlim = x_ext, ylim = y_ext)\ntext(points, labels = points$city, pos = 4, cex = 0.8, col = \"darkblue\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-4-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Check out the object\nclass(points)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SpatVector\"\nattr(,\"package\")\n[1] \"terra\"\n```\n\n\n:::\n:::\n\n\nThis example creates spatial points for Oxford, Rome, Swansea, Frankfurt, Zurich, and Paris, using their geographic coordinates (longitude, latitude), and displays them as blue dots.\n\n#### Coordinate reference systems (CRS)\n\nEvery spatial object must have an associated coordinate reference system (CRS). This defines how the coordinates relate to real-world locations. A consistent CRS ensures that all spatial layers align correctly and can be meaningfully compared for accurate mapping, analysis, and ecological interpretation. Defined CRS are also necessary to project spatial entities onto the curved surface of the Earth, translating the three-dimensional globe into a two-dimensional map. Without a proper projection, distances, areas, and spatial relationships can become distorted, leading to misleading ecological inferences or inaccurate spatial modeling.\n\nYou can check and change the CRS of a vector object using:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the CRS of a spatial object\ncrs(points)         # Check the CRS\n\n# Assign a new CRS (e.g., UTM Zone 32N)\ncrs(points) <- \"EPSG:32632\"\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### What is EPSG:4326?\n\nThe code 'EPSG:4326' refers to the 'WGS84' coordinate reference system — the global standard used by GPS. It is a geographic CRS that uses latitude and longitude in decimal degrees.\n\nYou may also see this specified using an older PROJ string:\n\n'+proj=longlat +datum=WGS84'\n\nWhile this still works, it’s now recommended to use the more modern and readable EPSG code (\"EPSG:4326\"), which ensures better compatibility across spatial tools and platforms.\n\n##### Other commonly used CRS\n\nDepending on your analysis or region of interest, other major coordinate systems are often used:\n\nEPSG:3857 — Web Mercator, used by most online map services (Google, OpenStreetMap).\n\nEPSG:27700 — British National Grid, used for detailed mapping in the UK.\n\nEPSG:5070 — USA Contiguous Albers Equal Area projection, suitable for continental-scale ecological analysis.\n\nEach CRS may serve slightly different analytical needs — global navigation, web mapping, or high-accuracy regional modelling, so choosing the right one is necessary for spatial accuracy and comparability.\n:::\n\n::: {.callout-tip collapse=\"true\" icon=\"lightbulb\"}\n### Tip: Always check CRS compatibility\n\nBefore combining or comparing spatial datasets, ensure they share the same CRS. Mixing different CRSs can lead to incorrect overlays, maps, or analyses.\n:::\n\n## 1.2 Lines and polygons in space\n\n### Representing Spatial Features Beyond Points\n\nIn spatial data presentation and analysis, **lines** and **polygons** are used to represent more complex spatial features:\n\n-   **Lines** can represent:\n    -   Animal migration paths (see [Movebank](https://www.movebank.org/cms/movebank-main) for real-world examples)\n    -   River courses\n    -   Transects used during field surveys\n-   **Polygons** are used for:\n    -   Protected habitat areas (e.g., national parks)\n    -   Land cover classes (e.g., forest, grassland)\n    -   Survey zones or administrative regions\n\n------------------------------------------------------------------------\n\n### Example: Drawing a migration path (line) and a protected area (polygon)\n\nLet's create a **line** connecting a sequence of waypoints representing a bird's migration route.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define coordinates along a hypothetical bird migration route for Greylag Goose (approximate, illustrative points)\nmigration_coords <- matrix(c(\n  15.0, 60.0,   # Northern Sweden breeding region\n   9.0, 56.0,   # Denmark / southern Sweden stopover\n   5.0, 52.0,   # Northern Germany\n   2.0, 48.0,   # Northeastern France / Alsace\n  -1.0, 44.0,   # Southwestern France\n   0.0, 40.0    # Northern Spain / wintering area\n), ncol = 2, byrow = TRUE)\n\n# Create a spatial line object\nmigration_line <- vect(migration_coords, type = \"lines\", crs = \"EPSG:4326\")\n```\n:::\n\n\nNow let’s define a polygon representing a protected habitat area along the migration corridor (e.g., a wetland reserve in France).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define polygon coordinates (rough bounding box for an example protected area)\nreserve_coords <- matrix(c(\n  1.0, 48.4,   # NW corner\n  1.0, 47.2,   # SW corner\n  2.2, 47.2,   # Mid-south (new point to bend the shape)\n  3.0, 47.4,   # SE corner (further east)\n  3.0, 48.4,   # NE corner\n  1.0, 48.4    # Close the polygon\n), ncol = 2, byrow = TRUE)\n\n# Create spatial polygon\nreserve_poly <- vect(reserve_coords, type = \"polygons\", crs = \"EPSG:4326\")\n```\n:::\n\n\nPlotting both: Migration route + protected area\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the individual extents\next_poly <- ext(reserve_poly)\next_line <- ext(migration_line)\n\n# Combine them using union\ncombined_ext <- terra::union(ext_poly, ext_line)\n\n# Plot the polygon with combined extent\nplot(reserve_poly, col = \"lightblue\", border = \"blue\",\n     ext = combined_ext,\n     main = \"Migration path and protected area\")\n\n# Add the migration line\nlines(migration_line, col = \"darkgreen\", lwd = 2)\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Insight: polygon closure\n\nPolygons must have their first and last point identical to form a closed shape — otherwise they won't render as expected.\n\nAlways verify your coordinate order and closure when constructing polygons manually.\n:::\n\n<br>\n\n## 1.3 Read Vector Data from Files\n\nIn real-world ecological and environmental projects, vector data are rarely created manually. Instead, they are typically stored in spatial file formats like:\n\n-   **Shapefile (`.shp`)** – the most widely used format for vector data; stores geometry and attributes across multiple sidecar files\n-   **GeoJSON (`.geojson`)** – web-friendly and human-readable\n-   **GPKG (GeoPackage)** – a modern, single-file spatial format\n-   **KML** – often used for visualisation in tools like Google Earth\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Insight: Common sources of vector-based biodiversity data\n\nWe live in an era of **big data**, where **biodiversity datasets** are increasingly available in digital format and at **global scale**. These data can come from:\n\n-   Standardised monitoring schemes\\\n-   Citizen science platforms\\\n-   Expert-drawn range maps\n\nEach data source has its own strengths and limitations. In this workshop, we’ll explore different types of spatial biodiversity data and how to load and visualise them in R.\n\nIn this session, we focus on basic description of data types, more on the species and environmental data will be described in after sections of the workshop.\n:::\n\n------------------------------------------------------------------------\n\n### Base maps as an example of polygons (using `rnaturalearth`)\n\nTo provide geographic context, we often need base maps of countries, continents, or regions. The `rnaturalearth`(https://github.com/ropensci/rnaturalearth) package provides an excellent interface to the Natural Earth datasets.\n\nBelow is the code used to create spatial objects for the **UK** and the **East Wales** region.\\\nThese have already been prepared in advance and saved to disk to speed up the workshop.\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Code to generate the spatial layers (already done in data preparation)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rnaturalearth)\nlibrary(sf)\n\n# Load country and region maps\nWorld_sf <- ne_countries(scale = \"medium\", returnclass = \"sf\")\nUK_sf <- ne_countries(scale = \"medium\", country = \"United Kingdom\", returnclass = \"sf\")\nUK_admin_sf <- ne_states(country = \"United Kingdom\", returnclass = \"sf\")\n\n# Subset to East Wales\nWalesEast_admin_sf <- UK_admin_sf[UK_admin_sf$region == \"East Wales\", ]\n```\n:::\n\n\nThese steps are included in the data preparation file:\\\n👉 [View full data preparation script](page_SDM.1_DataPreparation.qmd)\n:::\n\n<br>\n\n#### Visualise East Wales\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Load saved spatial objects\nlibrary(ggplot2)\nlibrary(sf)\n\n# Plot East Wales over the UK map\nggplot() +\n  geom_sf(data = UK_sf, fill = \"grey90\", color = \"black\") +\n  geom_sf(data = WalesEast_admin_sf, fill = \"steelblue\", color = \"darkblue\", size = 0.8) +\n  labs(\n    title = \"East Wales within the United Kingdom\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/plot-east-wales-1.pdf){fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Understanding spatial data structures in R\n\nFamiliarise yourself with the structure of `sp` and `sf` spatial data formats. In this workshop, we use modern packages like `sf` and `terra`, which follow the **Simple Features** standard for spatial vector data.\n\nUse the functions `crs()` (from **terra**) or `st_crs()` (from **sf**) to inspect and manipulate **coordinate reference systems (CRS)**. These determine how geometries relate to real-world locations and are essential when combining spatial layers.\n\nTo learn more, check the [Simple Features vignette](https://r-spatial.github.io/sf/articles/sf1.html) or run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvignette(\"sf1\", package = \"sf\")\n```\n:::\n\n\nThe website[rspatial.org](https://rspatial.org/), developed by a team of researchers led by Robert J. Hijmans, is an excellent resource for learning more about spatial data analysis and modeling in R.\n:::\n\n<br>\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Key spatial vector workflow skills\n\n-   Use `terra::vect()` to read shapefiles (e.g., IUCN range maps)\\\n-   Use `rnaturalearth::ne_countries()` to get base maps of countries or continents\\\n-   Combine both to map species ranges in a geographic context\\\n-   Always check file format, coordinate reference system (CRS), and attribute content when working with real-world spatial data\\\n:::\n\n<br> <br>\n\n## 2. Raster Data in R\n\nRaster datasets often come in file formats such as:\n\n-   **.tif (GeoTIFF)** — the most widely used raster format\n\n-   **.grd** — often used in older R workflows\n\n-   **.nc (NetCDF)** — commonly used in climate science\n\nWe use the `terra` package to read and manipulate raster data in R. From this package, the function `terra::rast()` is used to create or read `SpatRaster` objects (the primary raster data class in `terra`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a raster from scratch\nraster_1 <- terra::rast(ncol = 50, nrow = 50, xmin = 0, xmax = 50,  ymin = 0, ymax = 50)\n```\n:::\n\n\nWe can access the attributes of each raster cell by using the function `terra::values()`. Obviously, there are no values yet in the `SpatRaster` object and thus we assign some, generating random numbers with `rnorm()`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Check the summary stats of the values in raster_1:\nsummary(terra::values(raster_1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: [readValues] raster has no values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     lyr.1     \n Min.   : NA   \n 1st Qu.: NA   \n Median : NA   \n Mean   :NaN   \n 3rd Qu.: NA   \n Max.   : NA   \n NA's   :2500  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Assign values (randomly drawn from normal distribution) to the SpatRaster object:\nterra::values(raster_1) <- rnorm(ncell(raster_1))\n\n# plot the raster\nplot(raster_1)\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-align='center' fig-pos='H'}\n:::\n:::\n\n\nRaster resolution determines the spatial grain of your data — the size of each pixel on the ground. Higher resolution (e.g., 10m) provides more detail, but is computationally heavier.\n\nThis concept of spatial scale is crucial in ecology. Analyses done at fine scales may yield different insights than those at coarse scales.\n\nTo demonstrate this, we aggregate the raster to a coarser resolution. With multiple raster objects at hand, combine layers into a multi-layer `SpatRaster` object using the `terra::rast()` function to concatenate the layers.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Aggregate the raster to a coarser resolution (2x2)\nraster_2 <- aggregate(raster_1, fact = 2, fun = mean)\n\n# Match raster_2 (coarse) to raster_1 (fine resolution)\nraster_2_resamp <- resample(raster_2, raster_1, method = \"bilinear\")\n\n# Create multi-layer raster object\nraster_multi <- c(raster_1, raster_2_resamp)\n\n# Assign layer names\nnames(raster_multi) <- c(\"Fine resolution\", \"Coarse resolution\")\n\n# Plot the raster layers\nplot(raster_multi)\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-align='center' fig-pos='H'}\n:::\n:::\n\n\n## 2.1 Read raster data from files\n\nIn ecological and environmental research, raster data are commonly used to represent **continuous environmental variables** like climate, elevation, or land cover.\n\nOne widely used dataset is the **WorldClim v2.1 Bioclimatic Variables**, which provides global climate data at multiple resolutions. You can explore the available variables [here](https://www.worldclim.org/data/bioclim.html). To download and use these data in R, this can be efficiently done with the `geodata` package (part of the `rspatial` site developed by the [rspatial.org](https://rspatial.org/) group led by Robert J. Hijmans).\n\n### Code to download WorldClim 2.1 bioclimatic variables (already done in data preparation)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geodata)\n\n# download WorldClim 2.1 bioclimatic variables (10-minute resolution, this returns a SpatRaster with 19 layers, bio1 to bio19)\nClim_extant <- geodata::worldclim_global(var = \"bio\", res = 5, path = \"data/\")\n\n# Crop climate to UK\nClim_UK <- terra::crop(Clim_extant, UK_sf)\n```\n:::\n\n\nThese steps are included in the data preparation file:\\\n👉 [View full data preparation script](page_SDM.1_DataPreparation)\n\nWe can now extract the focal data of interest, here we crop the mean annual precipitation (bio12) data to the spatial extent of the UK.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| fig-width: 4\n#| fig-height: 5\n#| fig-align: left\n\n# Extract Bioclim variable 12: annual precipitation\nprecip_UK <- Clim_UK[[12]]  # bio12: annual precipitation in mm\n\n# Plot the precipitation map\nterra::plot(precip_UK, main = \"Mean annual precipitation (bio12) - UK\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\" icon=\"map\"}\n### Tip: Coordinate systems must match\n\nWhen working with raster and vector data together (e.g., cropping or masking), ensure both objects use the **same CRS**. Use `terra::project()` to reproject if needed.\n:::\n\n<br>\n\n## 2.2 Manipulate raster data\n\n##### Reproject raster data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reproject raster to a different CRS (e.g. British National Grid EPSG:27700)\nprecip_UK_proj <- terra::project(precip_UK, \"EPSG:27700\")\n\nterra::plot(precip_UK_proj, main = \"Precipitation (Reprojected)\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-16-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n##### Raster math / algebra\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| fig-width: 4\n#| fig-height: 5\n#| fig-align: left\n\n# Math / algebra example: Convert mm to cm for precipitation\nprecip_cm <- precip_UK / 10\n\n# Difference between original and converted\nterra::plot(precip_cm - precip_UK, main = \"Difference after unit conversion\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Apply mean filter with 3x3 window\nfocal_mean <- terra::focal(precip_UK, w = matrix(1, 3, 3), fun = mean, na.policy = \"omit\")\n\nterra::plot(focal_mean, main = \"Smoothed Precipitation (3x3 mean)\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-17-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n##### Zonal statistics\n\nSummarising raster data over polygonal spatial units is a common task in ecological and environmental analysis (and the broader field of applied data science). This is known as zonal statistics. For example, we can compute and visualise mean annual precipitation across UK administrative zones using the `terra` and `ggplot2` packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| fig-width: 4\n#| fig-height: 5\n#| fig-align: left\n\n# Add an ID column to UK_admin_sf (to explicitly match IDs between zonal_means and UK_admin_sf below)\nUK_admin_sf$admin_id <- 1:nrow(UK_admin_sf)\n\n# Convert UK_admin_sf to SpatVector\nzones_vect <- terra::vect(UK_admin_sf)\n\n# Compute mean precipitation by zone\nzonal_means <- terra::extract(precip_UK, zones_vect, fun = mean, na.rm = TRUE, ID = TRUE)\n\n# Preview output\nhead(zonal_means)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID   bio_12\n1  1 1504.444\n2  2 1716.789\n3  3 1312.486\n4  4 1131.222\n5  5 1029.231\n6  6 1376.529\n```\n\n\n:::\n\n```{.r .cell-code}\n# Replace NA values with 0 for demonstration purposes\n# !Note: This should be done cautiously — replacing NA may not be appropriate depending on your analysis.\nprecip_no_na <- terra::classify(precip_UK, cbind(NA, 0))\n\n# Merge zonal means (bio12 = mean annual precipitation) back to the spatial data (ensure correct ID match)\nUK_admin_sf$mean_precip_mm <- zonal_means$bio_12[match(UK_admin_sf$admin_id, zonal_means$ID)]\n\n# Plot the map of mean precipitation by zone\nggplot(UK_admin_sf) +\n  geom_sf(aes(fill = mean_precip_mm), color = \"white\") +\n  scale_fill_viridis_c(name = \"Annual Precipitation (mm)\", na.value = \"grey90\") +\n  labs(\n    title = \"Annual precipitation by UK administrative zone\",\n    caption = \"Data source: WorldClim 2.1 + Natural Earth\"\n  ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](page_SDM.2_SpatialDataR_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n<br>\n\n## 2.3 Extract Raster Values\n\nExtracting raster values at specific locations is a key step in many ecological and environmental workflows, particularly in species distribution modelling. This process allows us to link spatially continuous variables—such as climate or elevation—to discrete observation points, like species occurrence records. In this section, we demonstrate how to extract raster values using the `terra` package, both for point locations and across multiple raster layers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set seed for reproducibility\nset.seed(1)\n\n# Convert UK_sf object (an sf object) into a SpatVector object\nUK_vect <- terra::vect(UK_sf)\n\n# Simulate some (arbitrary) species occurrence points within the UK\nocc_points <- terra::spatSample(UK_vect[,1], size = 100, method = \"random\")\n\n# Extract raster values at these point locations\nocc_precip <- terra::extract(precip_UK, occ_points)\n\n# Combine coordinates and extracted values\nocc_df <- cbind(as.data.frame(occ_points), precip_mm = occ_precip[,2])\n\nhead(occ_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       featurecla precip_mm\n1 Admin-0 country       813\n2 Admin-0 country       897\n3 Admin-0 country       599\n4 Admin-0 country       857\n5 Admin-0 country       577\n6 Admin-0 country      1472\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract all 19 bioclim variables (multiple raster layers) for each point\nclim_data_vals <- terra::extract(Clim_UK, occ_points)\n\n# Combine with species occurrence coordinates\nclim_data_df <- cbind(as.data.frame(occ_points), clim_data_vals[,-1])  # Remove ID column\n\nhead(clim_data_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       featurecla    bio_1    bio_2    bio_3    bio_4    bio_5     bio_6\n1 Admin-0 country 7.281042 7.019583 38.77366 413.2269 17.42100 -0.683000\n2 Admin-0 country 9.604292 7.539417 37.85608 463.8675 21.04300  1.127000\n3 Admin-0 country 9.550167 8.080500 38.05275 486.4427 21.86000  0.625000\n4 Admin-0 country 6.861417 7.221333 38.35219 432.1033 17.46600 -1.363000\n5 Admin-0 country 9.800042 6.891583 34.70257 477.9860 21.01500  1.156000\n6 Admin-0 country 8.965159 7.169326 39.33672 417.4897 19.32128  1.095745\n     bio_7     bio_8     bio_9   bio_10   bio_11 bio_12 bio_13 bio_14   bio_15\n1 18.10400  7.780500  8.499666 12.63950 2.659833    813     85     55 15.05392\n2 19.91600  5.297667 13.855500 15.54483 4.369333    897    100     52 24.57603\n3 21.23500 10.247167  5.786000 15.72250 3.987000    599     59     37 13.67015\n4 18.82900  4.599000  8.310667 12.46333 1.977000    857     94     57 18.63359\n5 19.85900  7.771833  5.868667 15.91117 4.354167    577     61     34 19.14082\n6 18.22553  4.776773 12.928192 14.33546 4.185993   1472    171     84 25.41553\n  bio_16 bio_17 bio_18 bio_19\n1    240    172    190    208\n2    298    168    175    267\n3    172    127    144    148\n4    260    174    186    233\n5    174    112    158    141\n6    483    259    285    463\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Exercises: Load and Inspect a Raster\n\n1.  **Load and plot raster:**\\\n    Load the raster file `bioclim_01.tif` using the `terra` package. Plot the raster using a unique and appropriate color scale (e.g., `viridis`).\n\n2.  **Extract climate values at city locations:**\\\n    Use coordinates of 10 cities in the UK and Italy (or any other countries you choose). Extract and compare the climate values (mean annual temperature, bio1) at these points.\n\n3.  **Calculate zonal means for countries:**\\\n    Using polygon shapefiles of European countries or countries worldwide, calculate the zonal mean of bio1 (mean annual temperature) for each country. Visualize the result with a choropleth map.\n:::\n\n::: {.callout-note collapse=\"true\" icon=\"book\"}\n### Useful sources\n\nHijmans, R. J. (2023). *rspatial.org: Spatial Data in R*. <https://rspatial.org/>\n\nLovelace, R., Nowosad, J., & Muenchow, J. (2023). *Geocomputation with R*. <https://geocompr.robinlovelace.net>\n\nPebesma, E. (2023). *Simple Features for R: Standardized Support for Spatial Vector Data*. <https://r-spatial.github.io/sf/index.html>\n\nPebesma, E., & Bivand, R. (2025). *Spatial Data Science: With Applications in R.* <https://r-spatial.org/book/>\n:::\n\n<br>\n",
    "supporting": [
      "page_SDM.2_SpatialDataR_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}