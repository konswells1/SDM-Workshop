{
  "hash": "06bcaed8253e873693874c356774a79b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fitting & Comparing Algorithms\"\nformat: html\neditor: visual\ndraft: false\n---\n\n\n\n<br>\n\nSpecies Distribution Models (SDMs) can be built using a variety of algorithms, each with its own assumptions, strengths, and limitations. While earlier in this workshop we focused on fitting a simple Generalized Linear Model (GLM), this section broadens the scope to explore alternative approaches commonly used in ecological modelling and biogeography.\n\nWidely used SDM algorithms include:\n\n**Generalized Additive Models (GAM)**: Flexible regression models that capture non-linear relationships using smoothing functions.\n\n**Boosted Regression Trees (BRT / GBM)**: Ensemble models that combine many decision trees for robust predictions.\n\n**Random Forests**: A tree-based ensemble method that averages multiple models to improve accuracy and reduce overfitting.\n\n**MaxEnt**: A popular presence-only modelling method based on the principle of maximum entropy.\n\n**Bioclim**: A simple climatic envelope model based on observed environmental ranges (not covered in this workshop).\n\n**INLA (Integrated Nested Laplace Approximation)**: A Bayesian framework allowing spatially explicit modelling of species distributions.\n\n**Artificial Neural Networks (ANN)**: Flexible machine learning models that can capture complex non-linear relationships, though often harder to interpret.\n\nIn this section we will fit some of these algorithms to the same species–environment dataset in order to compare their predictive performance and understand how different methods respond to the same data. This comparison highlights the variability that can arise depending on algorithm choice, which is an important consideration when using SDMs for decision-making in conservation, land-use planning, or climate change impact assessment.\n\nThroughout this section, we will assess model performance using metrics such as AUC (Area Under the Curve), sensitivity, specificity, and TSS (True Skill Statistic). We will also explore how each algorithm predicts habitat suitability across geographic space, and discuss differences in their outputs.\n\nThis foundation will prepare us for the next step: **ensemble modelling**, where we combine the strengths of multiple algorithms to generate more robust and reliable predictions.\n\n## 1. Generalised Additive Models (GAMs)\n\nGeneralised Additive Models (GAMs) extend Generalised Linear Models (GLMs) by allowing for non-linear relationships between predictors and the response variable. In the context of species distribution modelling, GAMs can capture complex ecological responses to environmental gradients using smooth functions, rather than assuming a linear or quadratic form.\n\nGAMs are particularly useful when species responses to predictors (e.g., temperature, elevation, precipitation) are expected to be curved or irregular. This flexibility often improves model fit and interpretability without overfitting — especially when using automatic smoothing penalties.\n\nIn R, GAMs are commonly fitted using the `mgcv` package, which supports efficient estimation of smooth terms and model diagnostics.\n\n#### Fitting a GAM with `mgcv`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mgcv)\n\n# Fit GAM with smooth terms for selected predictors\ngam_model <- gam(pa ~ s(bio_1) + s(bio_12) + s(elevation), \n                 data = sdm_df_clean, \n                 family = binomial(link = \"logit\"))\n\nsummary(gam_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nFamily: binomial \nLink function: logit \n\nFormula:\npa ~ s(bio_1) + s(bio_12) + s(elevation)\n\nParametric coefficients:\n            Estimate Std. Error z value Pr(>|z|)  \n(Intercept)  -0.7553     0.2964  -2.548   0.0108 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nApproximate significance of smooth terms:\n               edf Ref.df Chi.sq  p-value    \ns(bio_1)     3.606  4.527  69.36  < 2e-16 ***\ns(bio_12)    5.018  5.984  41.26 2.28e-06 ***\ns(elevation) 3.093  3.933  66.84  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nR-sq.(adj) =  0.412   Deviance explained = 37.4%\nUBRE = -0.093788  Scale est. = 1         n = 658\n```\n\n\n:::\n:::\n\n\n**Plotting smooth effects**\n\nWe can plot the estimated smooth functions to explore how each predictor influences the probability of species presence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(gam_model, pages = 1, shade = TRUE, seWithMean = TRUE)\n```\n\n::: {.cell-output-display}\n![Smoothed relationships estimated by GAM for each predictor.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/gam-smooth-plots-1.png){width=672}\n:::\n:::\n\n\nThis visualisation helps interpret non-linear ecological responses. For example, a unimodal response to temperature might suggest an optimal thermal range for the species.\n\n#### Predicting habitat suitability with GAMs\n\nOnce a GAM is fitted, we can project it onto environmental raster layers to generate spatial predictions of habitat suitability.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(viridis)\n\n# Make sure the raster stack contains the same predictor names\nproj_stack <- Env_UK_stack[[c(\"bio_1\", \"bio_12\", \"elevation\")]]\nnames(proj_stack)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"bio_1\"     \"bio_12\"    \"elevation\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Predict using the GAM model\ngam_suitability <- terra::predict(proj_stack, gam_model, type = \"response\")\n\n# Plot the prediction\nplot(gam_suitability,\n     main = \"GAM-predicted habitat suitability\",\n     col = plasma(50))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/gam-projection-1.png){width=672}\n:::\n:::\n\n\n#### Evaluating GAM performance\n\nWe can evaluate the model using a hold-out test set or cross-validation. Here’s an example using a simple AUC-based assessment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\n\n# Fit GAM to training data only\ngam_model_train <- gam(pa ~ s(bio_1) + s(bio_12) + s(elevation), \n                 data = sdm_df_train, \n                 family = binomial(link = \"logit\"))\n\n# Predict on test data\ngam_predict_test <- predict(gam_model_train, newdata = sdm_df_test, type = \"response\")\n\n# Evaluate on test data\nroc_gam <- pROC::roc(sdm_df_test$pa, gam_predict_test)\nauc_gam <- pROC::auc(roc_gam)\n\n# Plot ROC\nplot(roc_gam, col = \"#1f78b4\", main = paste(\"GAM ROC Curve – AUC:\", round(auc_gam, 3)))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/gam-evaluation-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\" icon=\"lightbulb\"}\n#### Incorporating spatial structure in GAMs and GLMMs\n\nWhile the GAM example above focuses on smooth functions of environmental variables, GAMs can also include spatial effects by adding smooth terms for geographic coordinates, such as `s(x, y)`. This approach accounts for spatial autocorrelation, where observations close in space tend to be more similar than those farther apart — a common feature in ecological data.\n\nSimilarly, Generalized Linear Mixed Models (GLMMs), for example using the `glmmTMB` package, can incorporate spatial random effects or spatial covariance structures to capture unmeasured spatial variation. These methods improve model fit and inference by explicitly modelling spatial dependence rather than assuming observations are independent.\n\nRecognizing and incorporating spatial structure is essential for robust species distribution models, especially when ecological processes operate across space or when sampling design introduces spatial bias.\n\nHere is a simple example of fitting a GAM with a spatial smooth term using the `mgcv` package:\n\n##### Example: Fitting a GAM with a spatial smooth\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(mgcv)\n\n# Fit GAM with environmental predictors and spatial smooth\ngam_spatial <- gam(pa ~ s(bio_1) + s(bio_12) + s(elevation) + s(latitude, longitude),\n                   data = sdm_df_clean,\n                   family = binomial(link = \"logit\"))\n\n# Plot the spatial smooth term (usually the last smooth)\nplot(gam_spatial, select = length(gam_spatial$smooth), shade = TRUE,\n     main = \"Spatial smooth s(latitude, longitude)\")\n```\n:::\n\n\n##### Example: Fitting a GLMM with a spatial randnom effects\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glmmTMB)\nlibrary(spaMM)   # optional package for more advanced spatial covariance structures\n\n# -----------------\n# 1. Continuous spatial random effect (distance-based covariance)\n# -----------------\n\n# Define a numeric spatial factor from coordinates\nsdm_df_clean$pos <- numFactor(sdm_df_clean$longitude, sdm_df_clean$latitude)\n\n# Fit a GLMM with a spatially correlated random effect\nglmm_spatial <- glmmTMB(\n  pa ~ bio_1 + bio_12 + elevation + (1 | pos),\n  data = sdm_df_clean,\n  family = binomial(),\n  covstruct = list(pos = \"exp\")  # exponential spatial correlation\n)\n\nsummary(glmm_spatial)\n\n# -----------------\n# 2. Discrete spatial grouping effect (site-level random intercepts)\n# -----------------\n\n# Create a grouping factor that clusters nearby observations\nsdm_df_clean$spatgroup <- factor(paste0(\n  round(sdm_df_clean$latitude, 2), \"_\",\n  round(sdm_df_clean$longitude, 2))\n)\n\n# Fit a GLMM with a random grouping effect\nglmm_spatialgroup <- glmmTMB(\n  pa ~ bio_1 + bio_12 + elevation + (1 | spatgroup),\n  data = sdm_df_clean,\n  family = binomial()\n)\n\nsummary(glmm_spatialgroup)\n```\n:::\n\n\nNote: In spatial GLMMs, random spatial effects can be incorporated in two main ways: \n\n1) **Continuous spatial random effects**, where covariance betweens ties is a function of geographic distances (as in the 'numFactor()' example) \n\n2) **Discrete spatial grouping effects**, where nearby observations are assigned to the same group or grid cell (as in the 'spatgroup' example).\n\nThe first approach capture smooth, distance based spatial correlation and is closer to true geostatistical modelling, the second is simpler but often sufficient when data are highly clustered or when corrdiantes are coarse.\n:::\n\n## 2. Machine Learning–Based SDM Methods\n\nMachine learning (ML) methods have become increasingly popular in species distribution modelling due to their ability to model complex, non-linear relationships between species occurrence and environmental variables. Unlike traditional regression-based approaches (such as GLMs or GAMs), which require the modeller to explicitly define the form of each predictor (e.g., linear terms, polynomial terms, or smooth functions), machine learning models can automatically learn patterns, thresholds, and interactions from the data.\n\nAt their core, machine learning algorithms aim to find the statistical relationships or decision rules that best predict an outcome based on input features, typically by minimizing some form of prediction error. They do this by iteratively adjusting model parameters or structures in response to data, often without assuming any fixed functional form in advance.\n\nThis flexibility makes ML methods particularly valuable in ecological applications where relationships between species and environment may be unknown, non-linear, or influenced by multiple interacting factors. They are also well suited for large datasets with many predictors or complex structures, such as spatial or temporal autocorrelation.\n\n<br>\n\n::: {.callout-tip collapse=\"true\" icon=\"info-circle\"}\n### What does a machine learning model 'learn'?\n\nThe plot below shows a simplified example of how a machine learning algorithm (e.g. decision tree, random forest, or boosted tree) separates presence and absence records based on two environmental predictors. The algorithm automatically finds patterns and draws boundaries in the data space to predict species occurrence without the modeller needing to specify a particular equation. The model 'learns' by testing different patterns and combinations in the data, adjusting itself to improve predictions on new, unseen observations. This iterative process helps it find rules that generalize beyond the training examples.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/ml-boundary-demo-1.png){width=576}\n:::\n:::\n\n:::\n\n### 2.1 Boosted Regression Trees (BRG/GBM)\n\nBoosted Regression Trees (BRTs), also known as Gradient Boosting Machines (GBMs), are powerful machine learning models that combine the strengths of two methods: regression trees and boosting.\n\nA **regression tree** is a model that recursively splits the data based on predictor variables to reduce variance in the response. While a single tree may be simple and prone to overfitting, **boosting** builds an ensemble of many small trees in sequence. Each new tree focuses on the prediction errors made by the previous ones, gradually improving overall accuracy.\n\nThis iterative process makes BRTs highly flexible and effective at modelling complex ecological responses, including interactions and non-linear effects. They are particularly well-suited to species distribution modelling, where ecological relationships can be intricate and noisy.\n\nWe will use the `gbm.step()` function from the `dismo` package, which automates parameter tuning and cross-validation for BRTs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dismo)\nlibrary(gbm)\n\n# Data needs to in dataframe format for dismo::gbm.step()\nsdm_df_clean <- as.data.frame(sdm_df_clean)\n# Ensure response is numeric 1-0\nsdm_df_clean$pa <- as.numeric(as.character(sdm_df_clean$pa))\n\nbrt_model <- gbm.step(data = sdm_df_clean,\n                      gbm.x = c(\"bio_1\", \"bio_12\", \"elevation\"),\n                      gbm.y = \"pa\",\n                      family = \"bernoulli\",\n                      tree.complexity = 3,\n                      learning.rate = 0.01,\n                      bag.fraction = 0.5,\n                      verbose = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n \n GBM STEP - version 2.9 \n \nPerforming cross-validation optimisation of a boosted regression tree model \nfor NA and using a family of bernoulli \nUsing 658 observations and 3 predictors \ncreating 10 initial models of 50 trees \n\n folds are stratified by prevalence \ntotal mean deviance =  1.3854 \ntolerance is fixed at  0.0014 \nnow adding trees... \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-fit-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"info-circle\"}\n### Understanding the holdout deviance plot\n\n-   The plot shows **holdout deviance** (a measure of model error) on cross-validated data versus the number of trees in the Boosted Regression Tree (BRT) model.\n-   Lower deviance indicates better model fit.\n-   Each point o the line represents the deviance after adding that many trees.\n-   The red horizontal line marks the mean deviance at the optimal number of trees determined via cross-validation.\n-   The curve usually declines initially, then levels off; if it rises, overfitting may occur.\n-   Choosing the number of trees at the minimum deviance balances predictive performance and model complexity.\n\n> Even if the deviance curve looks smooth, cross-validation helps select a robust number of trees rather than relying solely on training data.\n:::\n\nOnce fitted, we can explore variable influence and partial dependence plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(brt_model)\n```\n\n::: {.cell-output-display}\n![Partial dependence plots from the BRT model showing species response to each predictor.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-effects-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                var  rel.inf\nbio_1         bio_1 44.65389\nbio_12       bio_12 27.81199\nelevation elevation 27.53412\n```\n\n\n:::\n\n```{.r .cell-code}\ngbm.plot(brt_model, n.plots = 3)\n```\n\n::: {.cell-output-display}\n![Partial dependence plots from the BRT model showing species response to each predictor.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-effects-2.png){width=672}\n:::\n:::\n\n\n**Predicting habitat suitability with the BRT**\n\nWe can now project the BRT model to the environmental raster layers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(viridis)\n\nproj_stack_sub <- Env_UK_stack[[c(\"bio_1\", \"bio_12\", \"elevation\")]]\nnames(proj_stack_sub) <- c(\"bio_1\", \"bio_12\", \"elevation\")  # ensure matching names\n\n# Predict habitat suitability\nbrt_prediction <- terra::predict(proj_stack_sub, brt_model, type = \"response\")\n\n# Mask to land area (optional: using the first raster as template)\n# This sets ocean/NA areas back to NA\nbrt_prediction <- mask(brt_prediction, proj_stack_sub[[1]])\n\n# Plot with color scale emphasizing land values\nplot(brt_prediction,\n     main = \"BRT-predicted habitat suitability\",\n     col = magma(50),\n     na.col = \"lightblue\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-projection-1.png){width=672}\n:::\n:::\n\n\n**Model evaluation**\n\nEvaluate the model on training data using AUC:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\n\n# Data needs to in dataframe format for dismo::gbm.step()\nsdm_df_train <- as.data.frame(sdm_df_train)\n# Ensure response is numeric 1-0\nsdm_df_train$pa <- as.numeric(as.character(sdm_df_train$pa))\n\n# Fit BRT to training data only\nbrt_model_train <- gbm.step(data = sdm_df_train,\n                      gbm.x = c(\"bio_1\", \"bio_12\", \"elevation\"),\n                      gbm.y = \"pa\",\n                      family = \"bernoulli\",\n                      tree.complexity = 3,\n                      learning.rate = 0.01,\n                      bag.fraction = 0.5,\n                      verbose = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n \n GBM STEP - version 2.9 \n \nPerforming cross-validation optimisation of a boosted regression tree model \nfor NA and using a family of bernoulli \nUsing 461 observations and 3 predictors \ncreating 10 initial models of 50 trees \n\n folds are stratified by prevalence \ntotal mean deviance =  1.3863 \ntolerance is fixed at  0.0014 \nnow adding trees... \n```\n\n\n:::\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-eval-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Predict on test data\nbrt_predict_test <- predict(brt_model_train, \n                           newdata= sdm_df_test, n.trees = brt_model_train$gbm.call$best.trees, type = \"response\")\n\nroc_brt <- pROC::roc(sdm_df_test$pa, brt_predict_test)\nauc_brt <- pROC::auc(roc_brt )\nplot(roc_brt, col = \"#ff7f00\", main = paste(\"BRT ROC Curve – AUC:\", round(auc_brt, 3)))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/brt-eval-2.png){width=672}\n:::\n:::\n\n\n### 2.2 Random Forests\n\n**Random Forests** are a powerful and widely used machine learning method in species distribution modelling. Like Boosted Regression Trees, they are based on ensembles of decision trees — but instead of boosting, Random Forests rely on **bagging** (bootstrap aggregation).\n\nEach tree in the forest is trained on a different random subset of the data. At each split, only a random subset of predictor variables is considered. This process reduces overfitting and makes the model more robust, particularly when dealing with correlated predictors or noisy data.\n\nIn SDM, Random Forests are valued for their high predictive accuracy, ability to handle non-linear and interactive effects, and their built-in estimates of variable importance.\n\nBelow we fit a Random Forest SDM using the `randomForest` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(randomForest)\n\n# Make sure 'pa' is a factor for classification\nsdm_df_clean$pa <- as.factor(sdm_df_clean$pa)\n\n# Fit the model\nrF_model <- randomForest(pa ~ bio_1 + bio_12 + elevation,\n                         data = sdm_df_clean,\n                         ntree = 500,\n                         importance = TRUE)\n\n# View variable importance\nprint(rF_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\n randomForest(formula = pa ~ bio_1 + bio_12 + elevation, data = sdm_df_clean,      ntree = 500, importance = TRUE) \n               Type of random forest: classification\n                     Number of trees: 500\nNo. of variables tried at each split: 1\n\n        OOB estimate of  error rate: 19.3%\nConfusion matrix:\n    0   1 class.error\n0 262  77   0.2271386\n1  50 269   0.1567398\n```\n\n\n:::\n\n```{.r .cell-code}\nvarImpPlot(rF_model, main = \"Random Forest Variable Importance\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/rF-fit-1.png){width=672}\n:::\n:::\n\n\n**Predict habitat suitability using Random Forest**\n\nWe now project the trained model onto the environmental raster layers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(viridis)\n\n# Prepare stack\nproj_stack <- Env_UK_stack[[c(\"bio_1\", \"bio_12\", \"elevation\")]]\nnames(proj_stack) <- c(\"bio_1\", \"bio_12\", \"elevation\")\n\n# Predict probability of presence\nrF_prediction <- terra::predict(proj_stack, rF_model, type = \"prob\", index = 2)\n\n# Plot prediction\nplot(rF_prediction,\n     main = \"Random Forest–predicted habitat suitability\",\n     col = inferno(50))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/rF-projection-1.png){width=672}\n:::\n:::\n\n\n**Evaluate model performance**\n\nWe use AUC and the ROC curve to evaluate predictive performance:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\n\n# Make sure 'pa' is a factor for classification\nsdm_df_train$pa <- as.factor(sdm_df_train$pa)\nsdm_df_test$pa <- as.factor(sdm_df_test$pa)\n\n# # Fit randomForest to training data only\nrF_model_train <- randomForest(pa ~ bio_1 + bio_12 + elevation,\n                         data = sdm_df_train,\n                         ntree = 500,\n                         importance = TRUE)\n\nrF_predict_test <- predict(rF_model_train, newdata= sdm_df_test, type = \"prob\")[, \"1\"]\n\nroc_rF <- pROC::roc(sdm_df_test$pa, rF_predict_test)\nauc_rF <- pROC::auc(roc_rF)\nplot(roc_rF, col= \"#33a02c\", main = paste(\"Random Forest ROC Curve – AUC:\", round(auc_rF, 3)))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/rF-eval-1.png){width=672}\n:::\n:::\n\n\nRandom Forests are often among the top-performing SDM algorithms, especially when the dataset is not too small. However, like other black-box models, they may lack transparency, so careful evaluation and interpretation of variable importance and response curves are recommended.\n\n### 2.3 Maxent\n\n**Maxent (Maximum Entropy)** is a widely used algorithms in species distribution modelling when only **presence data** are available. Unlike regression- or tree-based methods, which typically require both presence and absence points, Maxent estimates the species’ distribution by finding the probability distribution of maximum entropy (i.e., closest to uniform) constrained by the environmental conditions at known occurrence locations.\n\nIn practice, Maxent contrasts environmental conditions at occurrence points against conditions across a wider background area, identifying the combination of conditions that best explains the observed presences while avoiding overfitting. This makes it particularly useful for records where absences are unreliable or unknown such citizen museum datasets or science data.\n\nMaxent can be implemented in R via the `maxnet` package, which provides a native R re-implementation of the Maxent algorithm. Unlike the `dismo` package’s interface, which requires the standalone Java-based Maxent software, `maxnet` runs entirely in R and avoids Java dependencies. It fits presence–background models using the same maximum entropy framework, but with a formula interface that allows greater flexibility and integration into R workflows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(maxnet)\nlibrary(terra)\n\n# Extract environmental predictors at presence and background locations\npresence_vals <- terra::extract(proj_stack, vect(presence_sf)) %>%\n  dplyr::select(-ID)\nbackground_vals <- terra::extract(proj_stack, vect(target_group_sf)) %>%\n  dplyr::select(-ID)\n\n# Combine into one dataset\npa <- c(rep(1, nrow(presence_vals)), rep(0, nrow(background_vals)))\nenv_vals <- rbind(presence_vals, background_vals)\n\n# Remove rows with NA in predictors\ncomplete_idx <- complete.cases(env_vals)\nenv_vals_clean <- env_vals[complete_idx, ]\npa_clean <- pa[complete_idx]\n\n# Fit Maxent with maxnet\nmaxnet_model <- invisible(\n  suppressWarnings(\n    suppressMessages(\n      maxnet(\n        p = pa_clean,\n        data = env_vals_clean,\n        f = maxnet.formula(pa_clean, env_vals_clean)\n      )\n  )))\n```\n:::\n\n\nThe output includes model coefficients, variable contributions, and training performance metrics.\n\n**Visualising variable contributions**\n\nMaxent provides estimates of how much each predictor contributes to the model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(maxnet_model)\n```\n\n::: {.cell-output-display}\n![Variable importance estimates from the Maxent model.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/maxnet-var-imp-1.png){width=672}\n:::\n:::\n\n\n**Projecting habitat suitability with Maxent**\n\nOnce trained, the Maxent model can be projected across geographic space to estimate habitat suitability:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(maxnet)\n\n# 1. Extract raster values as data.frame\nenv_df <- as.data.frame(proj_stack, xy = TRUE, na.rm = FALSE)  # keep xy for plotting\n\n# 2. Identify rows without NA (complete cases)\ncomplete_idx <- complete.cases(env_df[, names(env_vals)])  # only predictor columns\n\n# 3. Predict with maxnet\npred_vals <- rep(NA, nrow(env_df))  # initialize output\npred_vals[complete_idx] <- predict(maxnet_model, env_df[complete_idx, names(env_vals)], type = \"cloglog\")\n\n# 4. Convert back to raster\nmaxent_prediction <- proj_stack[[1]]  # take first layer as template\nvalues(maxent_prediction) <- pred_vals\n\n# 5. Plot\nplot(maxent_prediction,\n     main = \"Maxent (maxnet) predicted habitat suitability\",\n     col = cividis(50))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/maxnet-project-1.png){width=672}\n:::\n:::\n\n\n**Evaluating model performance**\n\nWe can evaluate the Maxent model using AUC and the ROC curve, similar to other algorithms:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pROC)\n\n# Extract environmental values at presence and background points\npresence_vals <- terra::extract(proj_stack, vect(presence_sf)) %>% dplyr::select(-ID)\nbackground_vals <- terra::extract(proj_stack, vect(target_group_sf)) %>% dplyr::select(-ID)\n\n# Remove rows with NA\npresence_vals <- presence_vals[complete.cases(presence_vals), ]\nbackground_vals <- background_vals[complete.cases(background_vals), ]\n\n# {redict with maxnet model\npresence_probs <- predict(maxnet_model, presence_vals, type = \"cloglog\")\nbackground_probs <- predict(maxnet_model, background_vals, type = \"cloglog\")\n\n# Combine into evaluation vectors\neval_labels <- c(rep(1, nrow(presence_probs)), rep(0, nrow(background_probs)))\neval_probs <- c(presence_probs, background_probs)\n\n# ROC and AUC\nroc_maxnet <- pROC::roc(eval_labels, eval_probs)\nauc_maxnet <- roc_maxnet$auc\n\n# Plot ROC curve\nplot(roc_maxnet, col = \"#6a3d9a\", lwd = 2, main = paste(\"Maxent (maxnet) ROC Curve – AUC:\", round(auc_maxnet, 3)))\nabline(a = 0, b = 1, lty = 2, col = \"grey\")\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/maxnet-eval-1.png){width=672}\n:::\n:::\n\n\nMaxent is often praised for its strong performance with limited or biased presence-only data, but users should remain mindful of its assumptions. In particular, results are sensitive to the choice of background points and regularisation settings, and caution is required when extrapolating into novel environmental space (e.g., under future climate scenarios).\n\n## 3. Envelope-Based Models\n\n### 3.1 Bioclim\n\n**Bioclim** is one of the earliest and simplest species distribution modelling approaches.\\\nIt defines the species’ **environmental envelope** by summarizing the range of conditions (e.g., temperature, precipitation, elevation) at the observed occurrence locations. Predictions are then made by identifying areas in environmental space that fall within (or close to) this envelope.\n\nConceptually, Bioclim assumes that a species is equally likely to occur anywhere within its observed environmental limits. This makes it very intuitive and fast to compute, but also limited in its ability to model more complex, non-linear responses. Despite its simplicity, Bioclim is still useful as a **baseline SDM** and for teaching or comparison purposes.\n\nIn R, Bioclim can be fitted using the `bioclim()` function from the `dismo` package.\n\n**Fitting a Bioclim model**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\nlibrary(sf)\nlibrary(dplyr)\n\n# 1. Extract predictor values at presence points\npresence_vals <- terra::extract(proj_stack, vect(presence_sf)) %>% \n  dplyr::select(-ID)\n\n# 2. Remove any rows with NA\npresence_vals <- presence_vals[complete.cases(presence_vals), ]\n\n# 3. Compute climatic envelope for each predictor\nbioclim_min <- apply(presence_vals, 2, min)\nbioclim_max <- apply(presence_vals, 2, max)\n\nbioclim_model <- list(\n  min = bioclim_min,\n  max = bioclim_max\n)\n\nbioclim_model\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$min\n     bio_1     bio_12  elevation \n  7.412333 638.000000   8.870933 \n\n$max\n     bio_1     bio_12  elevation \n  10.82761 1647.00000  509.73306 \n```\n\n\n:::\n:::\n\n\n**Visualising Bioclim response curves**\n\nWe can plot the response curves to inspect the species’ environmental envelope:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Convert min/max ranges to long format for plotting\nenv_df <- data.frame(\n  predictor = names(bioclim_model$min),\n  min = bioclim_model$min,\n  max = bioclim_model$max\n) %>%\n  pivot_longer(cols = c(min, max), names_to = \"limit\", values_to = \"value\")\n\n# Plot\nggplot(env_df, aes(x = predictor, y = value)) +\n  # Lines connecting min-max in gray\n  geom_line(aes(group = predictor), color = \"gray\", size = 1.2) +\n  \n  # Points colored by limit\n  geom_point(aes(color = limit), size = 3) +\n  \n  # Horizontal ticks at min and max\n  geom_segment(aes(x = as.numeric(factor(predictor)) - 0.1, \n                   xend = as.numeric(factor(predictor)) + 0.1,\n                   y = value, yend = value,\n                   color = limit),\n               size = 1.2) +\n  \n  labs(x = \"Environmental predictor\",\n       y = \"Value\",\n       color = \"Envelope limit\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![Bioclim response curves showing the species’ environmental envelope.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/bioclim-response-1.png){width=672}\n:::\n:::\n\n\n**Projecting habitat suitability with Bioclim**\n\nOnce fitted, the Bioclim model can be projected across the study area:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(terra)\n\n# Extract raster values as a data.frame\nenv_df <- as.data.frame(proj_stack, xy = TRUE, na.rm = FALSE)\n\n# Compute suitability: 1 if all predictors within min/max, 0 otherwise\nsuitability <- apply(env_df[, names(bioclim_model$min)], 1, function(x) {\n  all(x >= bioclim_model$min & x <= bioclim_model$max)\n})\n\n# Initialize raster for predicted suitability\nbioclim_prediction <- proj_stack[[1]]  # template\nvalues(bioclim_prediction) <- NA       # reset\nvalues(bioclim_prediction)[!is.na(env_df[[1]])] <- suitability\n\n# Plot predicted suitability\nplot(bioclim_prediction,\n     main = \"Bioclim-predicted habitat suitability\",\n     col = c(\"lightgrey\", \"#FFC0C0\"),\n     legend = FALSE)\nlegend(\"topright\", legend = c(\"Unsuitable\", \"Suitable\"), fill = c(\"lightgrey\", \"#FFC0C0\"))\n```\n\n::: {.cell-output-display}\n![](page_SDM.8_SDMCompareAlgorithms_files/figure-html/bioclim-predict-1.png){width=672}\n:::\n:::\n\n\nBioclim’s simplicity makes it easy to implement and interpret, but it lacks the flexibility of regression- or machine-learning–based approaches. It assumes that all environmental conditions within the observed range are equally suitable, which is often unrealistic. Nevertheless, Bioclim provides a useful baseline comparator in SDM studies and highlights the importance of model choice in shaping predicted distributions.\n\n## 4. Advanced and Emerging Methods\n\nThe field of species distribution modelling is constantly evolving. Beyond classical statistical and machine learning approaches, a number of advanced or emerging methods are now being used in ecological research.\\\nThese methods offer new opportunities for handling spatial complexity, uncertainty, biotic interactions and ecological dynamics such as species dispersal and colonisation dynamics and very large datasets, but they may also require greater expertise, computational resources, or specialized software.\n\n### 4.1 Bayesian SDMs (e.g., INLA)\n\nBayesian approaches to SDMs provide a **probabilistic framework** that can incorporate prior knowledge, quantify uncertainty, and explicitly model spatial dependence. One of the most widely used implementations is **INLA (Integrated Nested Laplace Approximation)**, which allows efficient Bayesian inference for spatial models.\n\nKey features of Bayesian SDMs: - Explicitly account for **spatial autocorrelation** in species occurrences.\\\n- Allow incorporation of **prior knowledge** about ecological processes.\\\n- Provide **posterior distributions** for parameters and predictions, offering richer uncertainty estimates than single-value statistics like AUC.\\\n- Flexible framework: can include random effects, hierarchical structures, and complex spatial/temporal dependencies.\n\nLimitations: - Steeper learning curve compared to GLMs or Random Forests - Can be computationally demanding for large datasets\n\nINLA is implemented in the R package [`R-INLA`](https://www.r-inla.org/), though it requires some familiarity with Bayesian modelling concepts.\n\n<br>\n\n### 4.2 Joint species distribution modelling to account for biotic interactions\n\nMost classical SDMs assume that species distributions are shaped primarily by the **abiotic environment** (e.g., climate, topography, land cover). However, species do not occur in isolation. Their distributions are often influenced by **biotic interactions** such as competition, predation, facilitation, or mutualism.\n\n**Joint Species Distribution Models (jSDMs)** extend traditional SDMs by modelling the **occurrence of multiple species simultaneously**. This allows the estimation of both **species–environment relationships** and **species–species associations**, offering a more realistic ecological picture.\n\n#### Key features of jSDMs:\n\n-   **Shared responses to the environment**: capture similarities among species with similar niches.\\\n-   **Residual correlations**: identify co-occurrence patterns not explained by environment (potential biotic interactions).\\\n-   **Hierarchical framework**: often Bayesian, with species treated as partially exchangeable units.\\\n-   Can improve predictions, especially for **rare species** with few records, by \"borrowing strength\" from related species.\n\n#### Limitations:\n\n-   More complex to fit and interpret than single-species SDMs.\\\n-   Computationally demanding, especially with large species × site matrices.\\\n-   Correlations may reflect **unmeasured environmental covariates** rather than true biotic interactions — so ecological interpretation must be cautious.\n\nIn R, jSDMs can be fitted using packages such as:\\\n- **`Hmsc`**: Hierarchical modelling of species communities (supports spatial/temporal structure).\\\n- **`boral`**: Bayesian ordination and regression analysis of multivariate abundance data.\\\n- **`gjam`**: Generalized Joint Attribute Modelling, flexible for presence–absence, counts, or continuous traits.\n\n### 4.3 Dynamic and spatio-temporal SDMs\n\nWhile spatial SDMs are common, explicitly incorporating time (seasonality, interannual variability, long-term change, movement/dispersal and colonisation) is essential for capturing ecological dynamics and climate change impacts.\n\nKey features:\n\nCapture temporal dynamics in species-environment relationships.\n\nCan model shifts in species ranges over time.\n\nAllow exploration of lagged effects, seasonal cycles, or temporal autocorrelation.\n\nApproaches:\n\nTime-varying covariates in standard SDMs.\n\nSpatio-temporal models using INLA (R-INLA), mgcv::bam() for GAMs with time components.\n\nDynamic occupancy models (in unmarked, spOccupancy).\n\nTemporal models are especially relevant for climate change projections, phenology, or seasonal migrations.\n\n### 4.4 Neural networks and deep learning approaches to SDM\n\nNeural networks (NNs), including **deep learning** approaches, are increasingly being applied to SDMs, especially when working with **large, complex datasets** such as high-resolution remote sensing imagery or citizen science data.\n\nKey features: - Highly flexible models that can capture **complex non-linearities** and interactions.\\\n- **Convolutional Neural Networks (CNNs)** are particularly useful for incorporating spatially structured data such as satellite images or climate surfaces.\\\n- Capable of **end-to-end learning** (directly predicting species presence/absence from raw data).\n\nLimitations: - Require large datasets for training\\\n- Computationally intensive; often need GPUs or cloud computing\\\n- Models can be difficult to interpret (“black-box” nature)\n\nDespite these challenges, deep learning holds promise for applications such as **species recognition from images**, **integration of multiple data sources**, and **fine-scale spatial predictions**.\n\n### 4.5 Mechanistic / process-based models\n\nUnlike correlative models, which are based on statistical relationships between species occurrences and environmental variables, mechanistic SDMs explicitly model species distributions using physiological, behavioural, or demographic processes that are assumed to drive species occurrence, abundance, and distribution. These processes are represented through biomathematical functional relationships.\n\nExamples include: - Niche mapping (thermodynamic constraints on heat, water and nutritional balance) - Dynamic range models that simulate dispersal and colonization - Individual-based models (IBMs) t\n\nMechanistic SDMs offer important advantages over correlative models, including the ability to model novel climates more reliably and explicitly incorporate species traits and physiological limits. However, they require detailed species-specific data and are often complex and computationally intensive, making them less accessible for many applications. Linking mechanistic models to real-world patterns remains a challenge, and model validation approaches are still the subject of ongoing debate. To balance these trade-offs, so-called hybrid approaches that combine correlative and mechanistic elements are emerging as a powerful compromise.\n\n<br>\n\n## 5. Comparing SDM algorithms\n\nOnce multiple species distribution models are fitted, it is informative to compare their predictions and performance metrics. This helps learners and practitioners understand how algorithm choice affects model outputs and ecological interpretation.\n\n### 5.1 Performance metrics comparison\n\nKey metrics include:\n\nAUC (Area Under the ROC Curve): overall discriminatory ability.\n\nTSS (True Skill Statistic): balances sensitivity and specificity.\n\nSensitivity / Specificity: model’s ability to predict presences vs absences.\n\nDeviance or log-likelihood: for statistical models like GAMs.\n\nYou can compile a simple table of metrics for each model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_metrics <- data.frame(\n  Model = c(\"GAM\", \"BRT\", \"Random Forest\", \"Maxent\", \"Bioclim\"),\n  AUC = c(\n    auc_gam,    # GAM\n    auc_brt,    # BRT\n    auc_rF,     # RF\n    auc_maxnet, # Maxnet\n    NA          # Bioclim\n  )\n)\n\nknitr::kable(model_metrics, caption = \"Comparison of model performance (AUC) across SDM algorithms\")\n```\n\n::: {.cell-output-display}\n\n\nTable: Comparison of model performance (AUC) across SDM algorithms\n\n|Model         |       AUC|\n|:-------------|---------:|\n|GAM           | 0.8128901|\n|BRT           | 0.8602268|\n|Random Forest | 0.8686538|\n|Maxent        | 0.8446836|\n|Bioclim       |        NA|\n\n\n:::\n:::\n\n\n### 5.2 Performance metrics comparison\n\nVisual comparison of habitat suitability maps can highlight differences in predicted distributions, smoothness, and sensitivity to rare occurrences or extreme values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(viridis)\n\npar(mfrow = c(2,3))  # grid layout\n\nplot(glm_suitability_map, main = \"GLM\", col = viridis(50, option = \"D\"))\nplot(gam_suitability, main = \"GAM\", col = plasma(50))\nplot(brt_prediction, main = \"BRT\", col = magma(50))\nplot(rF_prediction, main = \"Random Forest\", col = inferno(50))\nplot(maxent_prediction, main = \"Maxent\", col = cividis(50))\nplot(bioclim_prediction, main = \"Bioclim\", col = c(\"lightgrey\", \"#FFC0C0\"))\n```\n\n::: {.cell-output-display}\n![Spatial predictions from different SDM algorithms for visual comparison.](page_SDM.8_SDMCompareAlgorithms_files/figure-html/compare-maps-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1,1))  # reset layout\n```\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"lightbulb\"}\n### Literature\n\nBakka, H., Rue, H., Fuglstad, G.-.A., Riebler, A., Bolin, D., Illian, J., Krainski, E., Simpson, D. & Lindgren, F. (2018). **Spatial modeling with R-INLA: A review.** *WIREs Computational Statistics*, 10(6), e1443. doi:10.1002/wics.1443\n\nDeneu, B., Servajean, M., Bonnet, P., Botella, C., Munoz, F., & Joly, A. (2021). **Convolutional neural networks improve species distribution modelling by capturing the spatial structure of the environment.** *PLOS Computational Biology*, 17(4), e1008856. doi:10.1371/journal.pcbi.1008856\n\nElith, J., Leathwick, J. R., & Hastie, T. (2008). **A working guide to boosted regression trees.** *Journal of Animal Ecology*, 77(4), 802–813. doi:10.1111/j.1365-2656.2008.01390.x\n\nElith, J., & Leathwick, J. R. (2009). **Species distribution models: ecological explanation and prediction across space and time.** *Annual Review of Ecology Evolution and Systematics*, 40, 677–697. doi:10.1146/annurev.ecolsys.110308.120159\n\nKearney, M. R., & Porter, W. P. (2020). **NicheMapR – an R package for biophysical modelling: the ectotherm and Dynamic Energy Budget models.** *Ecography*, 43(1), 85–96. doi:https://doi.org/10.1111/ecog.04680\n\nWood, S. N. (2017). **Generalized additive models. An introduction with R** ( 2nd ed.). CRC Press.\n\nPebesma, E., & Bivand, R. (2025). *Spatial Data Science: With Applications in R.* <https://r-spatial.org/book/>\n\nPhillips, S.J., Dudík, M., Elith, J., Graham, C.H., Lehmann, A., Leathwick, J. & Ferrier, S. (2009) **Sample selection bias and presence-only distribution models: Implications for background and pseudo-absence data.** *Ecological Applications*, 19(1), 181–197. [doi:10.1890/07-2153.1](https://doi.org/10.1890/07-2153.1)\n:::\n",
    "supporting": [
      "page_SDM.8_SDMCompareAlgorithms_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}