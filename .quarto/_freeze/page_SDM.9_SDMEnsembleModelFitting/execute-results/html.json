{
  "hash": "b209083673d87f978d6b5b606e271ab5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Ensemble Model Fitting\"\nformat: html\neditor: visual\ndraft: false\n---\n\n\n\nSpecies distribution models (SDMs) are, at best, imperfect approximations of reality. They rely on **human-defined mathematical structures** to represent complex ecological processes, forcing observational data into simplified functional forms that may not fully capture the underlying biological mechanisms. Each model is a filtered view, shaped by **assumptions, algorithmic constraints**, and the **quality of the available data**.\n\nExploring different **algorithms** for SDM has shown that every method carries its own strengths and limitations—no single model consistently outperforms others across species, regions, or scenarios. This recognition has led to the growing adoption of ensemble modelling, which combines predictions from multiple algorithms to generate more robust, reliable, and generalisable estimates of species’ potential distributions.\n\nThe core idea behind **ensemble modelling** is that each individual model captures a mix of signal (i.e. captures some of the genuine ecological patterns) and noise (errors, biases, or uncertainties). By aggregating across models, ensembles aim to amplify the signal while dampening the noise—leading to improved **predictive performance** and more defensible ecological inference.\n\nBy combining multiple models, ensemble approaches aim not only to amplify the signal and suppress the noise, but also to provide a more reliable central tendency (e.g. mean or consensus prediction) across different modelling approaches. Crucially, ensembles do more than just improve average predictive performance, as they also allow us to quantify uncertainty more effectively. By comparing variation among model predictions, we can estimate the degree of confidence in our forecasts and highlight areas of high or low agreement. This makes ensembles particularly valuable for decision-making and risk assessment under uncertainty, such as conservation planning or climate impact assessments.\n\n## 1. Ensemble Modelling Strategies\n\nEnsemble modelling in species distribution modelling (SDM) is not a single method but a framework that can incorporate different strategies for combining predictions. Broadly, ensemble methods can be grouped into three categories, depending on how models are weighted and how uncertainty is handled:\\\n\n#### 1.1 Simple averaging\n\nThe most basic ensemble method calculates the unweighted average of predictions from multiple models: • Every algorithm contributes equally to the final prediction. • Assumes all models are equally informative and reliable. • Easy to implement and interpret. When to use: When you have little prior reason to favour one model over another, or want a straightforward consensus.\\\n\n#### 1.2 Weighted averaging\n\nIn this approach, models are weighted according to performance metrics such as AUC, TSS, or cross-validated deviance: • Better-performing models contribute more heavily to the final ensemble. • Weights can be calculated based on internal validation (e.g., cross-validation AUC), independent test data, or expert judgment. When to use: When you want to prioritize models with stronger support from the data, while still retaining a diverse model set.\\\n\n#### 1.3 Consensus-based voting or thresholding\n\nHere, ensemble predictions are made by voting across binary outputs (e.g. habitat suitable/unsuitable): • A site is predicted suitable if a majority of models agree. • Can also use stricter rules (e.g. unanimity) or soft thresholds (e.g. 70% agreement). • Useful when decisions are binary (e.g. protect vs not protect) or when interpretation of continuous probabilities is unclear. When to use: In policy or management contexts that require clear thresholds for decision-making.\n\n::: {.callout-note collapse=\"true\" icon=\"info\"}\n### Practical Considerations for Ensemble Modelling\n\n#### Aligning model outputs\n\nBefore combining predictions from different SDM algorithms, it’s essential to ensure they are **aligned**:\n\n-   All models should be projected onto the **same spatial extent**, **resolution**, and use the same **environmental layers**.\n-   Predictions must be on the **same scale** (e.g. probabilities between 0 and 1).\n-   **Model names** should be clearly matched to their corresponding prediction layers or files to ensure reproducibility.\n\n#### Including uncertainty in ensembles\n\nWhile most ensemble implementations focus on generating a **central prediction** (e.g. mean or weighted mean), it is equally important to assess and communicate uncertainty:\n\n-   Include proxies for model disagreement, such as **standard deviation (SD)** across predictions.\n-   Calculate **quantiles** or **prediction intervals**, which are especially useful when communicating risk or making conservative decisions.\n-   It is good practice to report **both the ensemble mean and an uncertainty layer** (e.g. SD or interquartile range) in any spatial output intended for planning or publication.\n:::\n\n<br>\n\n## 2 Manual Ensemble Modelling\n\nAfter fitting multiple SDM algorithms and generating predictions on the same test dataset or raster stack, we can manually construct ensemble predictions by combining these outputs.\n\n#### 2.1 Prepare model predictions and evaluation metrics\n\nFor this example, suppose we have predicted probabilities from four based on GLM, GAM, BRT and randomForest models on the test data: `glm_predict_test`, `gam_predict_test`, `brt_predict_test`, `rF_predict_test` and their respective AUC values from validation: `auc_glm`, `auc_gam`, `auc_brt`, `auc_rF`\n\n#### 2.2 Simple average ensemble\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combine predictions into a data frame\nmodels_predict_df <- data.frame(GLM = as.numeric(glm_predict_test),\n                      GAM = as.numeric(gam_predict_test),\n                      BRT = as.numeric(brt_predict_test),\n                      RF  = as.numeric(rF_predict_test))\n\n# Simple average ensemble prediction\nensemble_predict_simple <- rowMeans(models_predict_df)\n```\n:::\n\n\n#### 2.3 Weighted average ensemble\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create weight vector based on AUCs\nmodels_auc_values <- c(auc_glm, auc_gam, auc_brt, auc_rF)\nweights_auc <- models_auc_values / sum(models_auc_values)\n\n\n# Weighted average ensemble prediction\nensemble_predict_weighted <- as.numeric(as.matrix(models_predict_df) %*% weights_auc)\n```\n:::\n\n\n#### 2.4 Quantify ensemble uncertainty\n\n\n::: {.cell}\n\n```{.r .cell-code}\nensemble_predict_sd <- apply(models_predict_df, 1, sd)\n```\n:::\n\n\n#### 2.4 Visualise ensemble prediction and uncertainty\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Create data frame for plotting\nplot_df <- tibble(\n  Observation = 1:length(ensemble_predict_simple),\n  SimpleMean = ensemble_predict_simple,\n  WeightedMean = ensemble_predict_weighted,\n  Uncertainty = ensemble_predict_sd\n) %>%\n  pivot_longer(cols = c(SimpleMean, WeightedMean), \n               names_to = \"EnsembleType\", values_to = \"Prediction\")\n\n# Plot predictions with uncertainty ribbon\nggplot(plot_df, aes(x = Observation, y = Prediction, color = EnsembleType)) +\n  geom_line() +\n  geom_ribbon(aes(ymin = Prediction - Uncertainty, ymax = Prediction + Uncertainty),\n              fill = \"grey80\", alpha = 0.3, color = NA) +\n  labs(title = \"Ensemble Predictions with Uncertainty\",\n       y = \"Predicted Probability\",\n       x = \"Test Sample Index\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](page_SDM.9_SDMEnsembleModelFitting_files/figure-html/ensemble-manual-visual-1.png){width=672}\n:::\n:::\n\n\n## 3. Packages for Constructing Ensemble SDMs in R\n\nR offers several packages for building and combining species distribution models, each with different strengths, model algorithms, and ways of handling ensemble predictions. Three commonly used tools are **`biomod2`**, **`sdm`**, and **`ENMeval`**.\n\n### 3.1 Using `biomod2`\n\n[`biomod2`](https://cran.r-project.org/package=biomod2) is a powerful and flexible package designed specifically for ensemble species distribution modelling. It supports a wide range of modelling algorithms (e.g., GLM, GAM, RF, Maxent), provides built-in tools for data preprocessing and evaluation, and includes robust ensemble functionalities.\n\n#### Key Features:\n\n-   Supports up to ten different SDM algorithms\n-   Automates cross-validation and model tuning\n-   Allows weighted ensemble predictions\n-   Can output uncertainty layers (e.g. confidence intervals, variance)\n\n#### `biomod2` basic Workflow\n\nHere is an outline of how to run ensemble SDMs using `biomod2`:\n\n##### `biomod2` step 1: Format the input data\n\nTo use biomod2, we need to provide presence–absence data coded as 1s and 0s, corresponding geographic coordinates (longitude and latitude), a stack of environmental predictor layers, a species name, and optional also background or absence points (if not provided will be generated by the package). Here we use the data generated earlier in the worshop (and stored also as saves/shared data for this worshop) and reformat then into the required object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(biomod2)\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\n\n# Load and prepare presence data\npresence_df <- presence_sf %>%\n  mutate(resp = 1) %>%                         # Add response variable (1 = presence)\n  st_coordinates() %>%                         # Extract coordinates\n  as.data.frame() %>%                          # Convert to data frame\n  bind_cols(resp = 1)                          # Append response column again for clarity\n\n# Load and prepare background (pseudo-absence) data\nbackground_df <- background_sf %>%\n  mutate(resp = 0) %>%                         # Add response variable (0 = background)\n  st_coordinates() %>%                         # Extract coordinates\n  as.data.frame() %>%                          # Convert to data frame\n  bind_cols(resp = 0)                          # Append response column again for clarity\n\n# Combine coordinates of presence and background points\nsdm_xy <- bind_rows(\n  st_coordinates(presence_sf) %>% as.data.frame(),      # Presence coordinates\n  st_coordinates(background_sf) %>% as.data.frame()     # Background coordinates\n)\n\n# Create corresponding response vector (1 = presence, 0 = background)\nsdm_resp <- c(rep(1, nrow(presence_sf)), rep(0, nrow(background_sf)))\n\n# Rename coordinate columns to match biomod2 requirements\ncolnames(sdm_xy) <- c(\"lon\", \"lat\")\n\n# Select focal environmental layers\nenv_select <- Env_UK_stack[[c(\"bio_1\", \"bio_12\", \"elevation\")]]\n\n# Convert terra SpatRaster to RasterStack (required by biomod2)\nenv_ras <- raster::stack(env_select)\n\n# Format data for biomod2 modelling\nbiomod_data <- BIOMOD_FormatingData(\n  resp.var = sdm_resp,              # Vector of 1s and 0s\n  expl.var = env_ras,               # Environmental predictors as RasterStack\n  resp.xy = sdm_xy,                 # Coordinates of all points\n  resp.name = \"Rhinolophus_hipposideros\",  # Species name (used to label outputs)\n  PA.nb.rep = 0                     # No pseudo-absence generation needed (already supplied)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n-=-=-=-=-=-=-=-=-=-= Rhinolophus_hipposideros Data Formating -=-=-=-=-=-=-=-=-=-=\n\n      ! Response variable name was converted into Rhinolophus.hipposideros\n !!! Some data are located in the same raster cell. \n          Please set `filter.raster = TRUE` if you want an automatic filtering.\n      ! No data has been set aside for modeling evaluation\n ! Some NAs have been automatically removed from your data\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Done -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n```\n\n\n:::\n:::\n\n\n##### `biomod2` step 2: Define and fit individual models\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set default model options (can be customised per algorithm)\nmod_options <- bm_ModelingOptions(data.type = 'binary',\n                            models = c(\"GLM\", \"RF\", \"GBM\", \"GAM\"),\n                            strategy = 'default')\n\n# Run SDMs using selected algorithms\n# Fit individual species distribution models using biomod2\nmyBiomodModelOut <- BIOMOD_Modeling(\n  bm.format = biomod_data,               # Formatted input data\n  modeling.id = \"AllModels\",             # Unique ID for this modelling run\n  models = c(\"GLM\", \"RF\", \"GBM\", \"GAM\"),  # SDM algorithms to fit\n  \n  # Cross-validation settings\n  CV.strategy = \"random\",                # Randomly split data into train/test\n  CV.nb.rep = 2,                         # Number of cross-validation replicates\n  CV.perc = 0.7,                         # 70% data used for training, 30% for testing\n  \n  # Model optimization and evaluation\n  OPT.strategy = \"bigboss\",             # Optimisation strategy (biomod2 default)\n  metric.eval = c(\"TSS\", \"ROC\"),        # Evaluation metrics to use\n  var.import = 2,                       # Number of permutations for variable importance\n  seed.val = 42                         # Random seed for reproducibility\n)\n```\n:::\n\n\n##### `biomod2` step 3: Build ensemble model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inspect model evaluation metrics for each algorithm and CV replicate\nget_evaluations(myBiomodModelOut) \n```\n:::\n\n\nThese evaluation results show that some models (e.g. RF) tend to have higher ROC/TSS etc., meaning better discrimination and more confidence; others may be lower, which suggests more caution or lower predictability under your environmental data.\n\n##### `biomod2` step 4: Ensemble prediction and uncertainty mapping\n\nHere we combine models, project them spatially, generate ensemble outputs (mean probability, weighted mean, and uncertainty), then forecast ensemble to new environmental rasters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Project individual models to environmental raster layers\nmodel_proj <- BIOMOD_Projection(\n  bm.mod        = myBiomodModelOut,\n  new.env       = env_ras,           # raster stack of environmental predictors\n  proj.name     = \"current\",         # a label for this projection scenario\n  binary.meth   = \"TSS\",             # thresholding method for binary maps\n  compress      = FALSE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n-=-=-=-=-=-=-=-=-=-=-=-=-= Do Single Models Projection -=-=-=-=-=-=-=-=-=-=-=-=-=\n\n\t> Building clamping mask\n\n\t> Projecting Rhinolophus.hipposideros_allData_RUN1_GLM ...\n\t> Projecting Rhinolophus.hipposideros_allData_RUN1_RF ...\n\t> Projecting Rhinolophus.hipposideros_allData_RUN1_GBM ...\n\t> Projecting Rhinolophus.hipposideros_allData_RUN2_GLM ...\n\t> Projecting Rhinolophus.hipposideros_allData_RUN2_RF ...\n\t> Projecting Rhinolophus.hipposideros_allData_RUN2_GBM ...\n\t> Projecting Rhinolophus.hipposideros_allData_allRun_GLM ...\n\t> Projecting Rhinolophus.hipposideros_allData_allRun_RF ...\n\t> Projecting Rhinolophus.hipposideros_allData_allRun_GBM ...\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Done -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n```\n\n\n:::\n\n```{.r .cell-code}\n# Build the ensemble using all cross-validation replicates\nmyEnsembleOut <- BIOMOD_EnsembleModeling(\n  bm.mod                = myBiomodModelOut,\n  em.by                 = \"all\",                     # combine all CV runs\n  em.algo               = c(\"EMmean\", \"EMcv\", \"EMwmean\"), # different ensemble methods: mean, coefficient of variation (CV=uncertainty), weighted mean\n  metric.select         = \"TSS\",                     # metric for selecting which models to include\n  metric.select.thresh  = 0.5                        # only include individual models with TSS ≥ 0.5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n-=-=-=-=-=-=-=-=-=-=-=-=-=-= Build Ensemble Models -=-=-=-=-=-=-=-=-=-=-=-=-=-=\n\n   ! all models available will be included in ensemble.modeling\n  ! Ensemble Models will be filtered and/or weighted using validation dataset (if possible). Please use `metric.select.dataset` for alternative options.\n   > Evaluation & Weighting methods summary :\n      TSS over 0.5\n\n!!! Removed models using the Full dataset as ensemble models cannot merge repetition dataset (RUN1, RUN2, ...) with Full dataset unless em.by = 'PA+run'.\n\n  > mergedData_mergedRun_mergedAlgo ensemble modeling\n   > Mean of probabilities by TSS ...\n\t\t\tEvaluating Model stuff...\n   > Coef of variation of probabilities by TSS ...\n\t\t\tEvaluating Model stuff...\n\t\t  original models scores =  0.51 0.533 0.606 0.606\n\t\t  final models weights =  0.226 0.236 0.269 0.269\n   > Probabilities weighting mean by TSS ...\n\t\t\tEvaluating Model stuff...\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Done -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n```\n\n\n:::\n\n```{.r .cell-code}\n# Apply the ensemble to the projections\nmyEnsembleProj <- BIOMOD_EnsembleForecasting(\n  bm.em   = myEnsembleOut,         # ensemble modeling object\n  bm.proj = model_proj             # projections from individual models\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n-=-=-=-=-=-=-=-=-=-=-=-= Do Ensemble Models Projection -=-=-=-=-=-=-=-=-=-=-=-=\n\nCreating suitable Workdir...\n\n\t> Projecting Rhinolophus.hipposideros_EMmeanByTSS_mergedData_mergedRun_mergedAlgo ...\n\t> Projecting Rhinolophus.hipposideros_EMcvByTSS_mergedData_mergedRun_mergedAlgo ...\n\t> Projecting Rhinolophus.hipposideros_EMwmeanByTSS_mergedData_mergedRun_mergedAlgo ...\n-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= Done -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n```\n\n\n:::\n\n```{.r .cell-code}\n# Visualise mean suitability, CV, and weigthed suitabilty onto map\n# Extract layers from biomod2 ensemble projection\nens_stack <- get_predictions(myEnsembleProj)\n\n# Rename for clarity (adjust names if needed)\nnames(ens_stack) <- c(\"Suitability_mean\", \"CV\", \"Suitability_weighted\")\n\n# Make 0-values in the weighted layer transparent\n# Set values of 0 to NA in the weighted layer\nens_stack$Suitability_weighted[ens_stack$Suitability_weighted == 0] <- NA\n\n# Plot all three side-by-side\nplot(ens_stack,\n     main = c(\"Mean Suitability\", \"Cross-Validation Variation\", \"Weighted Suitability\"),\n     colNA = \"transparent\",       # Show NA (0-values) as transparent\n     nc = 3,                      # Number of columns in layout\n     mar = c(2, 2, 2, 4))         # Margins\n```\n\n::: {.cell-output-display}\n![](page_SDM.9_SDMEnsembleModelFitting_files/figure-html/biomod2-ensemble-and-project-1.png){width=672}\n:::\n:::\n\n\n### 3.2 Using `sdm`\n\nThe `sdm` package in R is another powerful tool for species distribution modeling that supports many algorithms, cross-validation, and ensemble modeling. It is user-friendly and integrates well with spatial data.\n\n#### Key Features:\n\n-   Supports multiple algorithms (GLM, GAM, RF, Maxent, etc.)\n-   Easy setup of cross-validation and replication\n-   Built-in ensemble modeling and projection\n-   Outputs predictions and variable importance metrics\n\n#### `sdm` basic Workflow\n\nHere is an outline of how to run ensemble SDMs using `sdm`:\n\n##### `sdm` step 1: Format the input data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sdm)\nlibrary(terra)\nlibrary(sf)\nlibrary(dplyr)\n\n# Convert tibbles of pre-prepared sdm training and testing data subsets to base data.frames\nsdmData_df_train <- as.data.frame(sdm_df_train)[, c(\"pa\", \"bio_1\", \"bio_12\", \"elevation\")]\nsdmData_df_test  <- as.data.frame(sdm_df_test)[, c(\"pa\", \"bio_1\", \"bio_12\", \"elevation\")]\n\n# Make sure response variable is numeric\nsdmData_df_train$pa <- as.numeric(as.character(sdmData_df_train$pa))\nsdmData_df_test$pa  <- as.numeric(as.character(sdmData_df_test$pa))\n\n# Define formula using only selected predictors\nformula_selected <- pa ~ bio_1 + bio_12 + elevation\n\n# Create sdmData object using the pre-prepared sdm training and testing data subsets\nsdmData_df <- sdm::sdmData(\n  pa ~ bio_1+bio_12+elevation,\n  train = sdmData_df_train,\n  test = sdmData_df_test\n)\n```\n:::\n\n\n##### `sdm` step 2: Fit models with cross-validation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit SDMs using multiple algorithms with replication (e.g., CV)\n# Available algorithms: 'glm', 'rf', 'brt', 'svm', 'mars', 'gam', etc.\nsdm_model <- sdm::sdm(\n  formula = pa ~ bio_1 + bio_12 + elevation,\n  data = sdmData_df,\n  methods = c(\"glm\", \"gam\", \"rf\", \"brt\"),         # SDM algorithms\ntest.percent = 0   # use external test data supplied in sdmData_df\n  )\n```\n:::\n\n\n##### `sdm` step 3: Evaluate model performance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# View evaluation metrics: AUC, TSS, ...\neval_sdm <- sdm::getEvaluation(sdm_model, stat = c(\"AUC\", \"TSS\", \"sensitivity\", \"specificity\"))\n\nprint(eval_sdm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  modelID   AUC    TSS sensitivity specificity\n1       1 0.786 0.5146      0.9091      0.6055\n2       2 0.833 0.5788      0.9091      0.6697\n3       3 0.868 0.5743      0.8312      0.7431\n4       4 0.828 0.5590      0.7792      0.7798\n```\n\n\n:::\n:::\n\n\nAll four algorithms perform reasonably well at predicting species presence and absence, but there are differences in their strengths. The GLM (model 1) has very high sensitivity, meaning it rarely misses actual presences, but lower specificity, so it predicts some false presences. In contrast, the Random Forest (model 3) achieves the best overall balance (highest TSS) and good AUC, indicating it correctly predicts both presences and absences reliably. This illustrates why no single model is perfect, and why ensemble modelling — combining predictions from multiple algorithms — can improve robustness and account for different strengths and weaknesses of individual models.\n\n##### `sdm` step 4: Variable importance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assess variable importance\nvarimp_sdm <- getVarImp(sdm_model, id = 1:3)  # Adjust ID to match your models if needed\nplot(varimp_sdm)\n```\n\n::: {.cell-output-display}\n![](page_SDM.9_SDMEnsembleModelFitting_files/figure-html/sdm-varimp-1.png){width=672}\n:::\n:::\n\n\n##### `sdm` step 5: Project model spatially\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select focal environmental layers\nenv_select <- Env_UK_stack[[c(\"bio_1\", \"bio_12\", \"elevation\")]]\n\n# Project model onto environmental space\nsdm_proj <- predict(sdm_model, newdata = env_select, type=\"ensemble\")\n\n# Plot predictions\nplot(sdm_proj)\n```\n\n::: {.cell-output-display}\n![](page_SDM.9_SDMEnsembleModelFitting_files/figure-html/sdm-projec-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\" icon=\"lightbulb\"}\n### Literature\n\nAraújo, M. B., & New, M. (2007). **Ensemble forecasting of species distributions.** *Trends in Ecology and Evolution*, 22(1), 42–47.\n\nDormann Carsten, F., Calabrese Justin, M., Guillera‐Arroita, G., Matechou, E., Bahn, V., Bartoń, K., . . . Hartig, F. (2018). **Model averaging in ecology: a review of Bayesian, information‐theoretic and tactical approaches for predictive inference.** *Ecological Monographs*, 88(4): 485–504. [doi:10.1002/ecm.1309](https://doi.org/10.1002/ecm.1309)\n\nHao, T., Elith, J., Lahoz-Monfort, J. J., & Guillera-Arroita, G. (2020). **Testing whether ensemble modelling is advantageous for maximising predictive performance of species distribution models.** *Ecography*, 43(4), 549–558. [doi:10.1111/ecog.04890](https://doi.org/10.1111/ecog.04890)\n\nNaimi, B., & Araújo, M. B. (2016). **sdm: a reproducible and extensible R platform for species distribution modelling.** *Ecography*, 39(4), 368–375. [doi:10.1111/ecog.01881](https://doi.org/10.1111/ecog.01881)\n\nThuiller, W., Lafourcade, B., Engler, R., & Araújo, M. B. (2009). **BIOMOD - A platform for ensemble forecasting of species distributions.** *Ecography*, 32(3), 369–373. [doi/10.1111/j.1600-0587.2008.05742.x](https://doi.org/10.1111/j.1600-0587.2008.05742.x)\n\nZurell, D., Zimmermann, N. E., Gross, H., Baltensweiler, A., Sattler, T., & Wüest, R. O. (2020). **Testing species assemblage predictions from stacked and joint species distribution models.** *Journal of Biogeography*, 47(1), 101–113. [doi:10.1111/jbi.13608](https://doi.org/10.1111/jbi.13608)\n:::\n",
    "supporting": [
      "page_SDM.9_SDMEnsembleModelFitting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}