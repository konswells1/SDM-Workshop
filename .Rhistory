invisible(lapply(required_packages, function(pkg) {
suppressWarnings(suppressMessages(
library(pkg, character.only = TRUE)
))
}))
```
####
# Focal species for the SDM workshop
species_name <- "Rhinolophus hipposideros"
key <- name_backbone(name = species_name)$speciesKey
occ_data_rhinhipp <- occ_search(
taxonKey = key,
country = "GB",
hasCoordinate = TRUE,
limit = 2000
)
occ_df_rhinhipp <- occ_data_rhinhipp$data
# Note the date when GBIF data were downloaded
attr(occ_df_rhinhipp, "gbif_download_date") <- Sys.Date()
####
#  Target group species for species background data
# Define target group (Chiroptera = bats)
bat_taxon_key <- name_backbone(name = "Chiroptera")$usageKey
# Download bat occurrence records from GBIF
bat_occ <- rgbif::occ_search(
taxonKey = bat_taxon_key,
country = "GB",
hasCoordinate = TRUE,
limit = 10000  # increase if needed, but beware GBIF limits
)
# Extract data
bat_df <- bat_occ$data
# Remove records for the focal species (Rhinolophus hipposideros)
target_group_df <- bat_df %>%
# Select only the columns key, decimalLatitude, decimalLongitude
dplyr::select(species, key, decimalLatitude, decimalLongitude) %>%
# Remove records with missing coordinates
filter(!is.na(decimalLongitude), !is.na(decimalLatitude)) %>%
filter(!species %in% "Rhinolophus hipposideros") %>%
dplyr::select(species, decimalLatitude, decimalLongitude)
# Note the date when GBIF data were downloaded
attr(target_group_df, "gbif_download_date") <- Sys.Date()
# Convert to sf object
target_group_sf <- st_as_sf(
target_group_df,
coords = c("decimalLongitude", "decimalLatitude"),
crs = 4326
)
# Save vector and tabular data only
save(
World_sf, UK_sf, UK_admin_sf, WalesEast_admin_sf,
species_name, occ_df_rhinhipp, target_group_sf,
file = "data/workshop_data.RData"
)
# Save raster data separately as GeoTIFFs
terra::writeRaster(Clim_UK, "data/Clim_UK.tif", overwrite = TRUE)
terra::writeRaster(Elev_UK, "data/Elev_UK.tif", overwrite = TRUE)
terra::writeRaster(Clim_UK, "data/Clim_UK.tif", overwrite = TRUE)
terra::writeRaster(Elev_UK, "data/Elev_UK.tif", overwrite = TRUE)
terra::writeRaster(Clim_cmip6_2041_2060_UK, "data/Clim_cmip6_2041_2060_UK.tif", overwrite = TRUE)
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
getwd()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto install tinytex
install.packages("tinytex")
library(tinytex)
library(tinytex)
tinytex::install_tinytex()
tinytex::tinytex_root()
tinytex::tlmgr_update()
quarto::quarto_render()
quarto render . --to html,pdf
quarto::quarto_render()
par(mfrow = c(2,3))  # grid layout
plot(gam_suitability, main = "GAM", col = inferno(50))
formula_selected <- pa ~ bio_1 + bio_12 + elevation
sdm_df_train_df <- as.data.frame(sdm_df_train)
source("scripts/shared_sdm_data.R")
source("scripts/load_packages.R")
# Load shared environmental and species data
source("scripts/shared_sdm_data.R")
source("scripts/shared_sdm_models.R")
sdm_df_train_df <- as.data.frame(sdm_df_train)
sdm_df_test_df  <- as.data.frame(sdm_df_test)
formula_selected <- pa ~ bio_1 + bio_12 + elevation
sdm_df <- sdm::sdmData(
formula = pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train_df,
test = sdm_df_test_df
)
dim(sdm_df_train_df)
dim(sdm_df_test_df)
names(sdm_df_train_df)
names(sdm_df_test_df)
str(sdm_df_train_df$pa)
table(sdm_df_train_df$pa)
# Convert tibbles of pre-prepared sdm training and testing data subsets to base data.frames
sdm_df_train_df <- as.data.frame(sdm_df_train)
sdm_df_test_df  <- as.data.frame(sdm_df_test)
# Make sure response variable is numeric
sdm_df_train_df$pa <- as.numeric(as.character(sdm_df_train_df$pa))
sdm_df_test_df$pa  <- as.numeric(as.character(sdm_df_test_df$pa))
# Define formula using only selected predictors
formula_selected <- pa ~ bio_1 + bio_12 + elevation
# Create sdmData object using the pre-prepared sdm training and testing data subsets
sdm_df <- sdm::sdmData(
formula = pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train_df,
test = sdm_df_test_df
)
str(sdm_df_train_df$pa)
table(sdm_df_train_df$pa)
# Convert tibbles of pre-prepared sdm training and testing data subsets to base data.frames
sdm_df_train_df <- as.data.frame(sdm_df_train)
sdm_df_test_df  <- as.data.frame(sdm_df_test)
# Make sure response variable is numeric
sdm_df_train_df$pa <- as.numeric(as.character(sdm_df_train_df$pa))
sdm_df_test_df$pa  <- as.numeric(as.character(sdm_df_test_df$pa))
# Define formula using only selected predictors
formula_selected <- pa ~ bio_1 + bio_12 + elevation
# Create sdmData object using the pre-prepared sdm training and testing data subsets
sdm_df <- sdm::sdmData(
formula = pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train_df,
test = sdm_df_test_df
)
sdm_df <- sdm::sdmData(
formula = pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train_df,
test = sdm_df_test_df
)
str(sdm_df_test_df$pa)
table(sdm_df_test_df$pa)
table(sdm_df_train_df$pa)
?sdm::sdmData
str(sdm_df_test)
sdm_df <- sdm::sdmData(
formula = pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train,
test = sdm_df_test
)
str(sdm_df_clean[trainIndex, ])
as.numeric(as.character(sdm_df_train_df$pa))
as.numeric(as.character(sdm_df_test_df$pa))
str(as.numeric(as.character(sdm_df_test_df$pa)))
sdm_df <- sdm::sdmData(
pa ~ bio_1 + bio_12 + elevation,
train = sdm_df_train,
test = sdm_df_test
)
sdmData_df <- sdm::sdmData(
pa ~ bio_1+bio_12+elevation,
train = sdm_df_train,
test = sdm_df_test
)
sdmData_df <- sdm::sdmData(
pa ~ bio_1+bio_12+elevation,
train = sdm_df_train,
predictors = proj_stack,
test = sdm_df_test
)
sdmData(pa ~ bio_1+bio_12+elevation, train=sdm_df_train)
names(
sdmData(pa ~ bio_1+bio_12+elevation, train=sdm_df_train)
```)
names(
sdmData(pa ~ bio_1+bio_12+elevation, train=sdm_df_train)
```)
names(sdm_df_train)
sdm_df_train_df <- as.data.frame(sdm_df_train)[, c("pa", "bio_1", "bio_12", "elevation")]
names(sdm_df_train)
names(sdm_df_train_df)
sdm_df_train_df$pa <- as.numeric(as.character(sdm_df_train_df$pa))
sdmData(pa ~ bio_1+bio_12+elevation, train=sdm_df_train)
str(sdm_df_train)
sdmData(pa ~ bio_1+bio_12+elevation, train=sdm_df_train_df)
# Convert tibbles of pre-prepared sdm training and testing data subsets to base data.frames
sdmData_df_train <- as.data.frame(sdm_df_train)[, c("pa", "bio_1", "bio_12", "elevation")]
sdmData_df_test  <- as.data.frame(sdm_df_test)[, c("pa", "bio_1", "bio_12", "elevation")]
# Make sure response variable is numeric
sdmData_df_train$pa <- as.numeric(as.character(sdmData_df_train$pa))
sdmData_df_test$pa  <- as.numeric(as.character(sdmData_df_test$pa))
# Convert tibbles of pre-prepared sdm training and testing data subsets to base data.frames
sdmData_df_train <- as.data.frame(sdm_df_train)[, c("pa", "bio_1", "bio_12", "elevation")]
sdmData_df_test  <- as.data.frame(sdm_df_test)[, c("pa", "bio_1", "bio_12", "elevation")]
# Make sure response variable is numeric
sdmData_df_train$pa <- as.numeric(as.character(sdmData_df_train$pa))
sdmData_df_test$pa  <- as.numeric(as.character(sdmData_df_test$pa))
# Define formula using only selected predictors
formula_selected <- pa ~ bio_1 + bio_12 + elevation
# Create sdmData object using the pre-prepared sdm training and testing data subsets
sdmData_df <- sdm::sdmData(
pa ~ bio_1+bio_12+elevation,
train = sdmData_df_train,
test = sdmData_df_test
)
sdm_model <- sdm::sdm(
formula = pa ~ bio_1 + bio_12 + elevation,
data = sdmData_df,
methods = c("glm", "gam", "rf", "brt"),         # SDM algorithms
test.percent = 0   # use external test data supplied in sdmData_df
)
eval_sdm <- sdm::getEvaluation(sdm_model, stat = c("AUC", "TSS", "sensitivity", "specificity"))
print(eval_sdm)
eval_sdm
eval_sdm_summary <- eval_sdm %>%
group_by(method) %>%
summarise(
mean_AUC = mean(AUC, na.rm = TRUE),
mean_TSS = mean(TSS, na.rm = TRUE),
.groups = "drop"
)
eval_sdm
eval_sdm <- sdm::getEvaluation(sdm_model, stat = c("AUC", "TSS", "sensitivity", "specificity"))
eval_sdm
print(eval_sdm)
varimp_sdm <- getVarImp(sdm_model, id = 1:3)  # Adjust ID to match your models if needed
plot(varimp_sdm)
env_select <- Env_UK_stack[[c("bio_1", "bio_12", "elevation")]]
# Project model onto environmental space
sdm_proj <- predict(sdm_model, newdata = env_select)
plot(sdm_proj)
names(sdm_proj)
# Project model onto environmental space
sdm_proj <- sdm::predict(sdm_model, newdata = env_select)
# Project model onto environmental space
sdm_proj <- sdm::predict(sdm_model, newdata = env_select)
str(sdm_model)
sdm_proj <-predict(sdm_model, newdata = env_select, type="ensemble")
plot(sdm_proj)
plot(sdm_proj)
sdm_proj <-predict(sdm_model, newdata = env_select, method="ensemble")
?predict
sdm_proj <- terra::predict(sdm_model, newdata = env_select, method="ensemble")
sdm_proj <- terra::predict(sdm_model, newdata = env_select)
plot(sdm_proj)
sdm_proj <- predict(sdm_model, newdata = env_select, type="ensemble")
# Plot predictions
plot(sdm_proj)
plot(glm_suitability_map,
main = "Predicted habitat suitability for R. hipposideros (current)",
col = viridis(50, option = "D"))
library(rayshader)
install.packages("(rayshader")
library(rayshader)
install.packages("rayshader")
library(rayshader)
mat <- as.matrix(glm_suitability_map)
# Create a colored texture
cols <- viridis(50, option = "D")
mat_colors <- height_shade(mat, texture = cols)
library(raster)
mat <- as.matrix(glm_suitability_map)
# Optional: flip if needed to match spatial orientation
mat <- t(apply(mat, 2, rev))
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
# Convert raster to numeric matrix
mat <- as.matrix(glm_suitability_map)
# Make sure it's numeric
mat <- apply(mat, 2, as.numeric)
# Optional: flip matrix so orientation matches the map
mat <- t(apply(mat, 2, rev))
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
# Convert raster to numeric matrix
mat <- as.matrix(glm_suitability_map)
# Ensure it is numeric
mat <- apply(mat, 2, as.numeric)
# Remove NAs (rayshader cannot handle NAs in height matrix)
mat[is.na(mat)] <- 0
# Optional: flip matrix for correct orientation
mat <- t(apply(mat, 2, rev))
class(mat)       # should be "matrix"
mode(mat)        # should be "numeric"
dim(mat)
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
plot_3d(glm_suitability_map, mat, zscale = 10, fov = 0, theta = 45, phi = 30, windowsize = c(800,800))
# Convert raster to matrix
mat <- as.matrix(glm_suitability_map)
# Make sure it's numeric
mat <- apply(mat, 2, as.numeric)
# Replace NAs with zeros (rayshader cannot handle NA in heightmap)
mat[is.na(mat)] <- 0
# Flip the matrix so the orientation matches the raster
mat <- t(apply(mat, 2, rev))
# Check
class(mat)   # should be "matrix"
mode(mat)    # should be "numeric"
dim(mat)     # should match raster dimensions
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
> 1 and ncol > 1 for 3D plotting.
glm_suitability_map
# Look at nrow() and ncol()
nrow(glm_suitability_map)
ncol(glm_suitability_map)
mat <- as.matrix(glm_suitability_map, wide = TRUE)  # wide=TRUE ensures correct orientation
# Flip rows so the origin matches spatial orientation
mat <- t(apply(mat, 2, rev))
# Replace NAs with 0 (rayshader cannot handle NA in heightmap)
mat[is.na(mat)] <- 0
# Check
dim(mat)   # should be 130 x 119
class(mat) # matrix
mode(mat)  # numeric
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
plot_3d(
mat_colors,  # texture
mat,         # heightmap
zscale = 10, # vertical exaggeration
fov = 0,
theta = 45,  # rotation
phi = 30,    # elevation
windowsize = c(800, 800)
)
# Load required packages
library(terra)       # For raster handling
library(rayshader)   # For 3D plotting
library(viridis)     # For color palettes
library(rgl)         # For interactive 3D
library(htmlwidgets) # For saving interactive HTML
# -----------------------------
# 1️⃣ Convert raster to numeric matrix
# -----------------------------
# glm_suitability_map is a terra SpatRaster
mat <- as.matrix(glm_suitability_map, wide = TRUE)  # ensures correct column orientation
# Flip rows so that raster origin matches spatial orientation
mat <- t(apply(mat, 2, rev))
# Replace NAs with 0 (rayshader cannot handle NA values)
mat[is.na(mat)] <- 0
# Confirm matrix
dim(mat)
class(mat)
mode(mat)
# -----------------------------
# 2️⃣ Create a shaded texture using viridis
# -----------------------------
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
# -----------------------------
# 3️⃣ 2D Map Plot (optional, for comparison)
# -----------------------------
library(ggplot2)
library(reshape2)
# Convert matrix to data frame for ggplot
mat_df <- melt(mat)
colnames(mat_df) <- c("y", "x", "suitability")
ggplot(mat_df, aes(x = x, y = y, fill = suitability)) +
geom_raster() +
scale_fill_viridis_c(option = "D") +
coord_fixed() +
theme_minimal(base_size = 14) +
labs(title = "Predicted Habitat Suitability (2D)",
x = "X", y = "Y", fill = "Suitability")
# -----------------------------
# 4️⃣ 3D Plot with rayshader
# -----------------------------
plot_3d(
mat_colors,  # texture
mat,         # heightmap
zscale = 10, # vertical exaggeration
fov = 0,
theta = 45,  # horizontal rotation
phi = 30,    # vertical rotation
windowsize = c(800, 800)
)
render_camera(theta = 45, phi = 30, zoom = 0.7)
render_snapshot(filename = "glm_suitability_3D.png")
ggplot(mat_df, aes(x = x, y = y, fill = suitability)) +
geom_raster() +
scale_fill_viridis_c(option = "D") +
coord_fixed() +
theme_minimal(base_size = 14) +
labs(title = "Predicted Habitat Suitability (2D)",
x = "X", y = "Y", fill = "Suitability")
plot_3d(
mat_colors,  # texture
mat,         # heightmap
zscale = 10, # vertical exaggeration
fov = 0,
theta = 45,  # horizontal rotation
phi = 30,    # vertical rotation
windowsize = c(800, 800)
)
# Optional: adjust camera before saving
render_camera(theta = 45, phi = 30, zoom = 0.7)
# glm_suitability_map is a terra SpatRaster
mat <- as.matrix(glm_suitability_map, wide = TRUE)  # ensures correct column orientation
# Flip rows so that raster origin matches spatial orientation
mat <- t(apply(mat, 2, rev))
# Flip vertically (already done)
mat <- t(apply(mat, 2, rev))
# Flip horizontally to correct left-right mirroring
mat <- mat[, ncol(mat):1]  # reverse column order
# Replace NAs with 0 (rayshader cannot handle NA values)
mat[is.na(mat)] <- 0
# Confirm matrix
dim(mat)
class(mat)
mode(mat)
# -----------------------------
# 2️⃣ Create a shaded texture using viridis
# -----------------------------
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
# -----------------------------
# 3️⃣ 2D Map Plot (optional, for comparison)
# -----------------------------
library(ggplot2)
library(reshape2)
# Convert matrix to data frame for ggplot
mat_df <- melt(mat)
colnames(mat_df) <- c("y", "x", "suitability")
ggplot(mat_df, aes(x = x, y = y, fill = suitability)) +
geom_raster() +
scale_fill_viridis_c(option = "D") +
coord_fixed() +
theme_minimal(base_size = 14) +
labs(title = "Predicted Habitat Suitability (2D)",
x = "X", y = "Y", fill = "Suitability")
# -----------------------------
# 4️⃣ 3D Plot with rayshader
# -----------------------------
plot_3d(
mat_colors,  # texture
mat,         # heightmap
zscale = 10, # vertical exaggeration
fov = 0,
theta = 45,  # horizontal rotation
phi = 30,    # vertical rotation
windowsize = c(800, 800)
)
# Optional: adjust camera before saving
render_camera(theta = 45, phi = 30, zoom = 0.7)
# -----------------------------
# 1️⃣ Convert raster to numeric matrix
# -----------------------------
# glm_suitability_map is a terra SpatRaster
mat <- as.matrix(glm_suitability_map, wide = TRUE)  # ensures correct column orientation
# Flip rows so that raster origin matches spatial orientation
mat <- t(apply(mat, 2, rev))
# Flip vertically (already done)
mat <- t(apply(mat, 2, rev))
# Flip horizontally to correct left-right mirroring
mat <- mat[, ncol(mat):1]  # reverse column order
# Replace NAs with 0 (rayshader cannot handle NA values)
#### DO NOT    ########## mat[is.na(mat)] <- 0
# Create shaded texture, assign a color for NAs
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
mat_colors[is.na(mat)] <- "#00000000"  # fully transparent
# Confirm matrix
dim(mat)
class(mat)
mode(mat)
# -----------------------------
# 2️⃣ Create a shaded texture using viridis
# -----------------------------
mat_colors <- height_shade(mat, texture = viridis(50, option = "D"))
# -----------------------------
# 3️⃣ 2D Map Plot (optional, for comparison)
# -----------------------------
library(ggplot2)
library(reshape2)
# Convert matrix to data frame for ggplot
mat_df <- melt(mat)
colnames(mat_df) <- c("y", "x", "suitability")
ggplot(mat_df, aes(x = x, y = y, fill = suitability)) +
geom_raster() +
scale_fill_viridis_c(option = "D") +
coord_fixed() +
theme_minimal(base_size = 14) +
labs(title = "Predicted Habitat Suitability (2D)",
x = "X", y = "Y", fill = "Suitability")
plot_3d(
mat_colors,  # texture
mat,         # heightmap
zscale = 10, # vertical exaggeration
fov = 0,
theta = 45,  # horizontal rotation
phi = 30,    # vertical rotation
windowsize = c(800, 800)
)
# Optional: adjust camera before saving
render_camera(theta = 45, phi = 30, zoom = 0.7)
rglwidget() %>% htmlwidgets::saveWidget("glm_suitability_3D.html")
render_snapshot(filename = "glm_suitability_3D_static.png")
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
quarto::quarto_render()
